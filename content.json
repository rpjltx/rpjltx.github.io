[{"title":"Linux命令学习：数学运算","date":"2018-05-15T12:03:00.000Z","path":"2018/05/15/heuaa1q2/","text":"在Linux系统中，有很多不同的命令行工具可以完成数字运算，比如说expr、factor、jot 和 bc 命令。 一 expr首先，对于在命令行使用命令进行数学运算，可能最容易想到、最常用的命令就是 expr （表达式expression。它可以完成四则运算，也可以用于比较大小。下面是几个例子： 变量递增1234$ count=0$ count=`expr $count + 1`$ echo $count1 完成简单运算123456789101112$ expr 11 + 123134$ expr 134 / 1112$ expr 134 - 11123$ expr 11 * 123expr: syntax error &lt;== oops!$ expr 11 \\* 1231353$ expr 20 % 32 注意，你需要在 * 运算符之前增加 \\ 符号，避免语法错误。% 运算符用于取余运算。 下面是一个稍微复杂的例子：12345678participants=11total=156share=`expr $total / $participants`remaining=`expr $total - $participants \\* $share`echo $share14echo $remaining2 假设某个活动中有 11 位参与者，需要颁发的奖项总数为 156，那么平均每个参与者获得 14 项奖项，额外剩余 2 个奖项。 比较下面让我们看一下比较的操作。从第一印象来看，语句看似有些怪异；这里并不是设置数值，而是进行数字比较。在本例中 expr 判断表达式是否为真：如果结果是 1，那么表达式为真；反之，表达式为假。 1234$ expr 11 = 111$ expr 11 = 120 请读作“11 是否等于 11？”及“11 是否等于 12？”，你很快就会习惯这种写法。当然，我们不会在命令行上执行上述比较，可能的比较是 $age 是否等于 11。 123$ age=11$ expr $age = 111 如果将数字放到引号中间，那么你将进行字符串比较，而不是数值比较。 1234$ expr &quot;11&quot; = &quot;11&quot;1$ expr &quot;eleven&quot; = &quot;11&quot;0 在本例中，我们判断 10 是否大于 5，以及是否大于 99。1234$ expr 10 \\&gt; 51$ expr 10 \\&gt; 990 的确，返回 1 和 0 分别代表比较的结果为真和假，我们一般预期在 Linux 上得到这个结果。在下面的例子中，按照上述逻辑使用 expr 并不正确，因为 if 的工作原理刚好相反，即 0 代表真。123456789101112#!/bin/bashecho -n &quot;Cost to us&gt; &quot;read costecho -n &quot;Price we&apos;re asking&gt; &quot;read priceif [ `expr $price \\&gt; $cost` ]; then echo &quot;We make money&quot;else echo &quot;Don&apos;t sell it&quot;fi 下面，我们运行这个脚本：1234$ ./checkPriceCost to us&gt; 11.50Price we&apos;re asking&gt; 6We make money 这显然与我们预期不符！我们稍微修改一下，以便使其按我们预期工作：123456789101112#!/bin/bashecho -n &quot;Cost to us&gt; &quot;read costecho -n &quot;Price we&apos;re asking&gt; &quot;read priceif [ `expr $price \\&gt; $cost` == 1 ]; then echo &quot;We make money&quot;else echo &quot;Don&apos;t sell it&quot;fi 二 factorfactor命令用来计算输入数字的因子。例如： 12345678$ factor 111111: 3 37$ factor 134134: 2 67$ factor 1789417894: 2 23 389$ factor 19871987: 1987 三 jotjot 命令可以创建一系列数字。给定数字总数及起始数字即可。 123456789$ jot 8 101011121314151617 你也可以用如下方式使用 jot，这里我们要求递减至数字 2。 12345$ jot 4 10 210752 jot 可以帮你构造一系列数字组成的列表，该列表可以用于其它任务。 12345678$ for i in `jot 7 17`; do echo April $i; doneApril 17April 18April 19April 20April 21April 22April 23 四 bcbc 基本上是命令行数学运算最佳工具之一。输入你想执行的运算，使用管道发送至该命令即可： 12$ echo &quot;123.4+5/6-(7.89*1.234)&quot; | bc113.664 可见 bc 并没有忽略精度，而且输入的字符串也相当直截了当。它还可以进行大小比较、处理布尔值、计算平方根、正弦、余弦和正切等。 1234$ echo &quot;sqrt(256)&quot; | bc16$ echo &quot;s(90)&quot; | bc -l.89399666360055789051 事实上，bc 甚至可以计算 pi。你需要指定需要的精度。12345678$ echo &quot;scale=5; 4*a(1)&quot; | bc -l3.14156$ echo &quot;scale=10; 4*a(1)&quot; | bc -l3.1415926532$ echo &quot;scale=20; 4*a(1)&quot; | bc -l3.14159265358979323844$ echo &quot;scale=40; 4*a(1)&quot; | bc -l3.1415926535897932384626433832795028841968 除了通过管道接收数据并返回结果，bc还可以交互式运行，输入你想执行的运算即可。本例中提到的 scale 设置可以指定有效数字的个数。1234567891011$ bcbc 1.06.95Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.This is free software with ABSOLUTELY NO WARRANTY.For details type `warranty&apos;.scale=23/4.752/3.66quit 你还可以使用 bc 完成数字进制转换。obase 用于设置输出的数字进制。 1234567891011$ bcbc 1.06.95Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.This is free software with ABSOLUTELY NO WARRANTY.For details type `warranty&apos;.obase=1616 &lt;=== entered10 &lt;=== response256 &lt;=== entered100 &lt;=== responsequit 按如下方式使用 bc 也是完成十六进制与十进制转换的最简单方式之一： 1234$ echo &quot;ibase=16; F2&quot; | bc242$ echo &quot;obase=16; 242&quot; | bcF2 在上面第一个例子中，我们将输入进制（ibase）设置为十六进制（hex），完成十六进制到为十进制的转换。在第二个例子中，我们执行相反的操作，即将输出进制（obase）设置为十六进制。 五 简单的 bash 数学运算通过使用双括号，我们可以在 bash 中完成简单的数学运算。在下面的例子中，我们创建一个变量，为变量赋值，然后依次执行加法、自减和平方。 123456789101112$ ((e=11))$ (( e = e + 7 ))$ echo $e18$ ((e--))$ echo $e17$ ((e=e**2))$ echo $e289 允许使用的运算符包括： + - 加法及减法 ++ -- 自增与自减 * / % 乘法、除法及求余数 ^ 指数运算 你还可以使用逻辑运算符和布尔运算符： 1234567891011$ ((x=11)); ((y=7))$ if (( x &gt; y )); then&gt; echo &quot;x &gt; y&quot;&gt; fix &gt; y$ ((x=11)); ((y=7)); ((z=3))$ if (( x &gt; y )) &gt;&gt; (( y &gt; z )); then&gt; echo &quot;letters roll downhill&quot;&gt; filetters roll downhill 或者如下方式： 12$ if [ x &gt; y ] &lt;&lt; [ y &gt; z ]; then echo &quot;letters roll downhill&quot;; filetters roll downhill 下面计算 2 的 3 次幂： 1234$ echo &quot;2 ^ 3&quot;2 ^ 3$ echo &quot;2 ^ 3&quot; | bc8 以上，便是Linux系统下命令行对于数学计算的常用方法。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.renpingjun.top/tags/Linux/"}]},{"title":"JavaScript穷理尽微-字符串操作","date":"2018-03-04T01:03:00.000Z","path":"2018/03/04/ss3654gddh2/","text":"一 模版字符串（template string）在ES5以前，输出模版通常都是使用+对字符串进行拼接完成的，这种写法非常繁琐。于是ES6引入了模板字符串，模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量,变量名需要写在${}之中。 12let name = &quot;Renpingjun&quot;, time = &quot;today&quot;;let result = `Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 二 遍历器接口ES6为字符串添加了遍历器接口，使得字符串可以被for…of循环遍历。 123456789for (let codePoint of &apos;pepsi&apos;) &#123; console.log(codePoint)&#125;// &quot;p&quot;// &quot;e&quot;// &quot;p&quot;// &quot;s&quot;// &quot;i&quot; 三 常用方法1 indexOf()indexOf()方法可返回某个指定的字符串值在字符串中首次出现的位置,如果要检索的字符串值没有出现，则返回 -1。用法如下： 12let str = &quot;pepsi&quot;;console.log(str.indexOf(p)); //0 2 includes(), startsWith(), endsWith() includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。 12345let s = &apos;Hello world!&apos;;s.startsWith(&apos;Hello&apos;) // trues.endsWith(&apos;!&apos;) // trues.includes(&apos;o&apos;) // true 3 repeat()repeat()方法返回一个新字符串，表示将原字符串重复n次。 1&apos;x&apos;.repeat(3) // &quot;xxx&quot; 4 padStart()，padEnd()如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。12345&apos;x&apos;.padStart(5, &apos;ab&apos;) // &apos;ababx&apos;&apos;x&apos;.padStart(4, &apos;ab&apos;) // &apos;abax&apos;&apos;x&apos;.padEnd(5, &apos;ab&apos;) // &apos;xabab&apos;&apos;x&apos;.padEnd(4, &apos;ab&apos;) // &apos;xaba&apos; 四 字符串和正则表达式字符串对象共有4个方法，可以使用正则表达式：match()、replace()、search()和split()。 1 match()match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配,返回的是指定的值。 2 replace()replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 3 search()search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。返回相匹配的字符串起始位置，如果没有找到任何匹配的子串，则返回 -1。 4 split()split() 方法用于把一个字符串分割成字符串数组。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.renpingjun.top/tags/JavaScript/"}]},{"title":"JavaScript穷理尽微-操作符","date":"2018-03-03T11:03:00.000Z","path":"2018/03/03/349a10oj7/","text":"在JavaScript中，操作符是用来操作数据值的，适用于字符串、数值、布尔值，甚至对象。只不过在应用于对象时，相应的操作符会调用对象的valueOf() 或toString()方法，以便取得可以操作的值。常见的操作符包括算数操作符、关系操作符、相等操作符和位操作符等。 一 一元操作符只能操作一个值的操作符叫做一元操作符。一元操作符是ECMAScript中最简单的操作符。 1 递增和递减递增和递减有前置和后置两种算法类型，前置型就是位于要操作的变量之前，后置型就是位于要操作的变量之后。代码示例：12let age = 24;++ age; //age = 25 在这个例子中，前置递增操作符把age的值变成了25。实际上这个效果等同于age = age + 1。相似地，前置递减操作会从变量中减去1。 后置递增（减）操作符与前置递增（减）操作符的区别在于递增和递减是在包含它们的语句被求值之后才执行的。示例代码：1234let count1 = 2;let count2 = 20;let count3 = count1-- + count2; //22let count4 = count1 + count2; //21 2 一元加和减一元加操作符放在数值前对数值不会产生任何影响，放在非数值前时则会将该值隐式转换成数值类型。示例代码：12345678910let a = &quot;1.2&quot;,b = true, c = &quot;haha&quot;, d = &#123; valueOf:function()&#123; return -1 &#125; &#125;;a = +a; //1.2b = +b; //1c = +c; //NaNd = +d; //-1 一元减操作符主要用于表示负数，如将1转为-1。 二 位操作符位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。在JavaScript中，所有数值都是按664位格式存储的，但位操作符并不直接操作64位的值，二是先将64位值转成32位，执行操作结束后在换成64位。 对于有符号的整数，32位中的前31位用于表示整数的值，第32位用于表示数值的符号：0表示正数，1表示负数。这个表示符号的位叫做符号位，符号位的值决定了其他位数值的格式。其中正数以纯二进制格式存储，31位中的每一位都表示2的幂，从右向左依次是20, 21, 22……依次类推。 负数同样以二进制码存储，但使用的格式是二进制补码。计算一个数值的二进制补码过程如下：（1）求这个数值绝对值的二进制码；（2）求二进制反码，即将0换成1，将1换成0；（3）得到的二进制反码加1。 需要注意的是，在处理有符号整数时，是不能访问位31的，ECMAScript会隐藏这些信息。也就是说，在以二进制字符串形式输出一个负数时，我们看到的只是这个数值的绝对值的二进制码前面加了个符号。代码示例：12let num = -18;console.log(num.toString(2)); // -10010 1 按位非（NOT）按位非操作符由一个波浪线（～）表示，执行按位非的结果就是返回数值的反码。按位非操作的本质是：操作数的负值减1。示例代码：12let num = 25;let num2 = ~num; //num2 = -26, 相当于num2 = -num1 -1 2 按位与（AND）按位与操作符由符号（&amp;）表示，它有两个操作符数。从本质上讲，按位与操作就是将两个数值的每一位对齐，然后根据下表规则对相同位置上的两个数执行AND操作。 第一个数值的位 第二个数值的位 结果 1 1 1 1 0 0 0 1 0 0 0 0 示例代码：12let result = 25 &amp; 3;console.log(result); //1 3 按位或（OR）按位或操作符由一个竖线（|）表示，和按位与操作符一样，它也有两个操作符数，操作方法也是将两个数值的每一位对齐，然后根据下表规则对相同位置上的两个数执行OR操作。 第一个数值的位 第二个数值的位 结果 1 1 1 1 0 1 0 1 1 0 0 0 示例代码：12let result = 25 | 3;console.log(result); //27 4 按位异或（XOR）按位异或操作符由一个插入符号（^）表示，也有连个操作符数。以下是按位异或的真值表。 第一个数值的位 第二个数值的位 结果 1 1 0 1 0 1 0 1 1 0 0 0 示例代码：12let result = 25 | 3;console.log(result); //26 关于25和3的按位与、按位或、按位异或的底层操作如下图示： 5 左移左移操作符由两个小于号（&lt;&lt;）表示。该操作符会将数值的所有位向左移动指定的位数，左移操作多出来的空位会以0来填充。需要注意的是左移不会影响操作的符号位。代码示例： 12345let num = 2; //等于二进制0000 0000 0000 0000 0000 0000 0000 0010let num2 = num &lt;&lt; 5; // 等于二进制0000 0000 0000 0000 0000 0000 0100 0000console.log(num2); // 64let num3 = -2 &lt;&lt; 5; // -64 6 有符号右移有符号的右移操作符由两个大于号（&gt;&gt;）表示，该操作符会将数值向右移动，但保留符号位。在移动过程中，原数值也会出现空位，只不过这次出现在原数值的左侧、符号位的右侧。而此时ECMAScript会用符号位的值来填充所有空位，以便得到一个完整的值。示例代码：123let num4 = 64;; // 等于二进制0000 0000 0000 0000 0000 0000 0100 0000let num5 = num4 &gt;&gt; 5; // 等于二进制0000 0000 0000 0000 0000 0000 0000 0010console.log(num5); // 2 7 无符号右移无符号右移操作符由三个大于号（&gt;&gt;&gt;）表示，这个操作符会将数值的所有32位都向右移动。对正数来说，无符号右移和有符号右移结果相同。对负数来说，首先是无符号右移是以0来来填充右移过程中出现的空位，其次是无符号右移操作会把负数的二进制码当成正数的二进制码。这样导致的结果就是：由于负数以其绝对值的二进制补码形式表示，无符号右移后的结果非常之大。示例：123let num6 = -64;let num7 = num6 &gt;&gt;&gt; 5console.log(num7); // 134217726 三 逻辑操作符逻辑操作符也叫布尔操作符，一共有三个：非（NOT）、与（AND）、或（OR）。 1 逻辑非逻辑非操作符由一个叹号（！）表示，可应用于ECMAScript中任何类型的数据，返回结果都是一个布尔值。12!123; // false!false; // true 2 逻辑与逻辑与操作符由两个和号（&amp;&amp;）表示，逻辑与的真值表如下： 第一个操作数 第二个操作数 结果 true true true true false false false true false false false false 逻辑与操作可以应用于任何类型数据的操作。它的操作规则如下：（1）：如果第一个操作数是对象，则返回第二个操作数；（2）如果第二个操作数是对象，只有第一个操作数返回结果为true时，才返回该个对象；（3）如果两个操作数都是对象，则返回第二个操作数；（4）如果有一个操作数是null，则返回null；（5）如果有一个操作数是NaN，则返回NaN；（6）如果有一个操作数是undefined，则返回undefined。 逻辑与操作属于短路操作，即如果第一个操作能够决定结果，则不进行第二个操作。 3 逻辑或逻辑或操作符由两个竖线符号（||）表示，有两个操作数，其真值表如下所示： 第一个操作数 第二个操作数 结果 true true true true false true false true true false false false 逻辑或的操作规则如下：（1）如果第一个操作数是对象，则返回第一个操作数；（2）如果第一个操作数的返回结果为false，则返回第二个操作数；（3）如果两个操作数都是对象，则返回第一个操作数；（4）如果两个操作数都是null，则返回null；（5）如果两个操作数都是NaN，则返回NaN；（6）如果两个操作数都是undefined，则返回undefined。 和逻辑与操作符相似，逻辑或操作符也是短路操作符。我们可以利用逻辑或的特性来避免为变量赋null或undefined值：1let info = preferredInfo || backupInfo 四 乘性操作符ECMAScript定义了三个乘性操作符，分别是：乘法、除法和求模（取余）。 1 乘法乘法操作符由一个星号（*）表示，用于计算两个数值的乘积。如果乘积超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity。1let result = 2 * 5;// 10 2 除法除法操作符由一个斜线符号（/）表示，执行第二个操作数除第一个操作数的计算。同样的，如果商超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity。 1let result = 48 / 3;// 16 3 求模（取余）求模操作符由一个百分号（%）表示，执行第二个操作数除第一个操作数并返回余数的计算。 1let result = 16 % 3; // 1 五 加性操作符1 加法操作符加法操作符（+）用于计算两个数值的和。计算规则如下：（1）如果两个操作数都是数值，则执行常规的计算方法；（2）如果两个操作数有一个是字符串，则转成字符串后连个操作值拼接，如果两个都是字符串则直接拼接；（3）如果有一个操作数是对象、布尔，则调用他们的toString（）方法取得相应的字符串在进行拼接。示例代码： 12let result1 = 2 + 3; // 5let result2 = 2 + &quot;3&quot;; // &quot;23&quot; 2 减法操作符减法操作符（-）用于计算两个数值的差。计算规则如下：（1）如果两个操作数都是数值，则执行常规的计算方法；（2）如果有一个操作数是NaN，则返回NaN；（3）Infinity - Infinity = NaN，- Infinity - - Infinity = NaN，Infinity - -Infinity = Infinity， - Infinity - Infinity = Infinity；（4）如果有一个操作数是字符串、布尔、null或undefined，则先调用Number（）方法将其转成数值再进行计算；（5）如果一个操作数是对象，则先调用valueOf（）取得该对象的数值再进行计算，如果没有valueOf（）则调用toString（）并将得到的字符串转成数值再计算。示例代码： 12345let result1 = 5 - true; // 4let result2 = NaN -2; // NaNlet result3 = 5 - &quot;&quot;; // 5let result4 = 5 - &quot;2&quot;; // 3let result5 = 5 - null; // 5 六 关系操作符关系操作符用于两个数值进行比较，包括小于（&lt;）,大于（&gt;）,小于等于（&lt;=）,大于等于（&gt;=），返回结果都是一个布尔值。计算规则如下：（1）如果两个操作数都是数值，则执行数值比较；（2）如果两个操作数都是字符串，则比较两个操作数对应的字符编码值；（3）如果一个操作数是数值，则将另一个操作数转成数值再进行比较；（4）如果一个操作数是布尔，则先将其转成数值再进行比较；（5）如果一个操作数是对象，则先调用valueOf（）取得该对象的数值再进行计算，如果没有valueOf（）则调用toString（）并将得到的字符串转成数值再计算。 七 相等操作符判断连个变量是否相等是编程中的一个非常重要的操作。ECMAScript提供了两组操作符：相等和不相等，全等和不全等。相等操作符由两个等号（==）表示，不相等操作符由叹号加等号（！=）表示，这两个操作符都会先转换操作数（通常称为强制转换），然后再进行比较。全等操作符（===）和不全等操作符（！==）则不会转换操作数类型，因此在判断式不仅比较数值是否相等，还比较类型是否一致。在实际项目开发中，为了保持代码的一致性，推荐使用全等操作符和不全等操作符。 八 条件操作符条件操作符也叫三目运算符，其基本语法如下：1let result = boolean_expression ? true_value : false_value 九 赋值操作符赋值操作符由等号（=）表示，其作用是把右侧的值赋给左边的变量。如果在等号左边加上算数操作符或位操作符，就可以完成复合赋值操作（*=, /=, +=, -=等）。 十 逗号操作符使用逗号操作符可以在一条语句中执行多个操作。逗号操作符多用于声明多个变量。如下所示：1let a = 12, b = &quot;pepsi&quot;, c = true;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.renpingjun.top/tags/JavaScript/"}]},{"title":"JavaScript穷理尽微-数据类型","date":"2018-03-03T01:03:00.000Z","path":"2018/03/03/koi328d209j/","text":"一 数据类型ECMAScript有7中数据类型，分别是Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）和Symbol。其中Symbol是ES6为了从根本上防止属性名命名冲突新增加的。 1 UndefinedUndefined类型只有一个值，即特殊的undefined。在声明了一个变量但未对其进行初始化，这个变量的值就是undefined。 2 NullNull类型也只有一个值，即null，null值表示一个空对象指针。 如果定义的变量准备在将来用于保存对象，那么应该在变量初始化时设为null。这样做的好处是只要检查null值就可以知道相应的变量是否已经保存了一个对象的引用。示例代码： 123if(data != null)&#123; doSomething()&#125; 3 BooleanBoolean类型有两个字面值：true和false。Boolean()函数可以将任何数据类型的值转换为Boolean值。至于这个值是true还是false，则取决于要转换值的数据类型和实际值。 数据类型 转换为true 转换为false Boolean true false String 非空字符 “” Number 非0数字 0和NaM Object 任何对象 null 4 StringString类型即字符串，用于表示由0个或多个16位Unicode字符组成的字符序列，可以用引号表示。 String数据类型包含一些特殊的字符字面量，叫转义符，用于表示非打印字符，或者具有其他用途的字符。 字面量 含义 \\n 换行 \\t 制表 \\b 退格 \\r 回车 \\ 斜杠 \\’ 引号 字符串转换有两个函数：toString()和String()。由于null和undefined没有toString()方法，在不知道要转换的值是不是null和undefined时，可以使用String()方法，这个函数能够将任何类型的数值转换为字符串。String()方法转换规则如下： 如果值有toString()方法，则调用该方法并返回相应的结果； 如果值是null，则返回“null”； 如果值是undefined，则返回“undefined”。 5 NumberNumber类型表示数值，通常包含两种数值：整数和浮点数。最基本的数值字面量格式是十进制，也是默认格式。 除此之外还可以通过八进制和十六进制格式的字面量来表示。八进制字面值的第一位必须是0，然后是八进制数字序列（0-7）。如果字面值的数值超出了范围，那么前面的0将被忽略，后面的数值将被当作十进制进行解析。十六进制字面值的前两位必须是0x，后面跟任何十六进制数值（0-9，A-F），字母不区分大小写。注意：在进行算数计算时，不管是八进制还是十六进制都将被转换成十进制数值。 需要特殊说明的是NaN，NaN是一个特殊的数值，这个数值表示一个本来要返回数值的操作数未返回数值的情况。NaN有两个特点：一是任何设计NaN的操作都会返回NaN，二是NaN与任何值都不相等，包括自身。针对这两个特点，ECMAScript定义了isNaN（）函数，用于判断所传值是否不是数值。 关于数值转换有三个函数：Number(), parseInt(), parseFloat()。 数据类型 Number() Number 返回十进制的数值 Boolean true转成1，false转成0 null 返回0 undefined 返回NaN String 如果字符串为空则返回0；如果字符串只包含数字，则转成十进制数值；如果字符串包含有效的浮点格式，则转成对应的浮点数值；如果字符串中包含十六进制数值，则转成对应的十进制数值；其他情况返回NaN Object 先调用valueOf()方法，然后依照上面规则转换；如果转换结果是NaN，则调用对象的toString()方法，然后再依照上面规则转换返回的字符串值 parseInt() 函数可解析一个字符串，并返回一个整数。parseInt() 函数在转换字符串时，如果第一个字符不是数字或负号，则会返回NaN，空字符串也会返回NaN； parseFloat() 函数可解析一个字符串，并返回一个浮点数。对parseFloat() 函数来说，只有字符串的第一个小数点有效第二个小数点后面的将被忽略。 6 ObjectECMAScript中的对象其实就是一组数据和方法的集合。对象可以通过new关键字+要创建的对象类型的名称来创建，如 var o = new Object(),实际开发中我们通常直接通过字面量来定义一个对象，如 var o = {}。 7 SymbolSymbol值通过Symbol函数生成。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。1234let s = Symbol();typeof s// &quot;symbol&quot; 关于Symbol类型的值，有两点需要注意：一是相同参数的Symbol函数的返回值是不相等的；二是Symbol值不能与其他类型的值进行运算。 二 数据类型判断1 typeoftypeof是最常见的数据类型判断方法，可以根据不同的值返回7个结果，返回的类型都是字符串形式。示例： 12345678var a,b = &#123;&#125;,c = function()&#123;&#125;,d = Symbol();typeof a;// &quot;undefined&quot;typeof 2;// &quot;number&quot;typeof &quot;renpingjun&quot;;// &quot;string&quot;typeof true;// &quot;boolean&quot;typeof b;// &quot;object&quot;typeof c;// &quot;function&quot;typeof d;//&quot;symbol&quot; 使用typeof判断非常简单，到也会有一些问题，比如typeof null返回结果是object，而且在数组、正则、日期、对象上的判断都是返回object。由此可以引出另一个判断方法Object.prototype.toString()。 ECMAScript的特殊对象类型：Array、Function、Math、Date、JSON、RegExp、Error，每种类型都各自代表一种独立的类，不同的类实例拥有不同的类特性以及对应的操作方式。 2 Object.prototype.toStringtoString()方法返回一个描述某对象的字符串，如果此方法在自定义的对象中未被覆盖，则toString()返回”[object type]”,其中type是对象类型。在使用toString()方法检测对象类型时，常用Object.prototype.toString.call()来检测。示例： 1234567Object.prototype.toString.call(new Date());// [object Date]Object.prototype.toString.call(new String());// [object String]Object.prototype.toString.call(new Array());// [object Array]Object.prototype.toString.call(Symbol());// [object Symbol]Object.prototype.toString.call(Math);// [object Math]Object.prototype.toString.call(undefined);// [object Undefined]Object.prototype.toString.call(null);// [object Null] 3 constructorconstructor 属性返回所有 JavaScript 变量的构造函数。因此我们可以使用 constructor 属性来查看对象是否为某类型，示例：123function isArray(myArray) &#123; return myArray.constructor.toString().indexOf(&quot;Array&quot;) &gt; -1;&#125; 三 数据类型转换在JavaScript中，数据类型转换方法有三种：分为转换函数、显式转换和隐式转换。转换函数包含上文提到的toString()、parseInt()、parseFloat()等方法。显式转换包括上文中提到的Boolean()、String()、Number()等方法。接下来主要谈谈隐式转换。 1 Number加减乘除以及取余等操作符都可以让字符串隐式转换成number。 123var a = &quot;234&quot;;a = +a;typeof a;// &quot;number&quot; 2 String使用连接符 +“”可以其他的类型转换成string类型。123var num = 123;var str = num + &quot;&quot;;console.log(str, typeof str);//&quot;123&quot;,string 3 Boolean使用取反运算符。1234var num = undefined;var res = !!num;console.log(res); //falseconsole.log(typeof res);boolean","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.renpingjun.top/tags/JavaScript/"}]},{"title":"JavaScript穷理尽微-解构赋值","date":"2018-03-02T07:03:00.000Z","path":"2018/03/02/nw23jd23uejd9/","text":"一 什么是解构赋值解构，deconstruction，原意为分解，拆解等。解构赋值本质上是一种匹配模式,只要等号两边的模式相同,那么就可以将值从数组或属性从对象拆解开来提取到不同的变量中。如果解构不成功，变量的值就等于undefined。 二 解构赋值举例1 数组1let [a, b, c] = [1, 2, 3]; 示例代码表明，可以从数组中提取值，按照对应位置对变量进行赋值。 2 字符串字符串也可以进行解构赋值，是因为字符串有长度，而且可以被转换成了一个类似数组的对象。1let [a, b, c, d, e] = &apos;hello&apos;; 3 对象对象的解构与数组解构的不同之处在于：数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。123let &#123; bar, foo &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;let &#123; foo: baz &#125; = &#123; foo: &apos;aaa&apos;, bar: &apos;bbb&apos; &#125;; 4 数值和布尔值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 5 函数1[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b); //[3,7] 三 应用场景变量的解构赋值应用场景很多。 1 交换变量的值例如需要把 a = 3,b = 4 变成 a = 4, b = 3。最常规的方法就是引入第三方变量：12345let a = 3,b = 4;let temp = a;a = b;b = temp;console.log(a, b); 这样虽然能实现，但引入了一个多余的变量。于是第二种方法出现了：12345let a = 3,b = 4;a += b;b = a - b;a -= b;console.log(a, b); 在不引入第三方变量的情况下实现了需求，但细心的同学就会发现这也是有问题的，即整型数据溢出，比如说对于32位字符最大表示有符号数字是2147483647，也就是Math.pow(2,31)-1，如果是2147483645和2147483646交换就失败了。为了解决这个bug，我们可以利用一个数异或本身等于０和异或运算符合交换率。12345let a = 3,b = 4; a ^= b; b ^= a; a ^= b;console.log(a, b); 需要说明的是：^ 即”异或“运算符，^ 运算符的特点是与0异或，保持原值；与本身异或，结果为0。 ES6的解构赋值就厉害了，直接交换变量a和b的值，这样的写法不仅简洁，而且易读，语义非常清晰。 12let a = 3,b = 4;[a,b] = [b,a]; 2 从函数返回多个值函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。 我们可以利用解构赋值从函数返回多个值。1234function foo() &#123; return [1, 2, 3];&#125;let [a, b, c] = foo(); 3 函数参数的定义解构赋值可以方便地将一组参数与变量名对应起来。1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 4 提取JSON数据123456789let jsonData = &#123; id: 42, status: &quot;OK&quot;, data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number); 5 函数参数的默认值123456789const compare = (property, method = &quot;ASC&quot;) =&gt; &#123; return (obj1, obj2) =&gt; &#123; let v1 = obj1[property],v2 = obj2[property]; if(method == &quot;DESC&quot;) return v2 - v1 else return v1 - v2 &#125;&#125; 示例代码中，在参数中给method设置了默认值，就避免了在函数体内部再写let method = method == “ASC”:”DESC”这样的语句。 6 遍历Map结构Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。123456789var map = new Map();map.set(&apos;first&apos;, &apos;hello&apos;);map.set(&apos;second&apos;, &apos;world&apos;);for (let [key, value] of map) &#123; console.log(key + &quot; is &quot; + value);&#125;// first is hello// second is world 7 输入模块的指定方法加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。1const &#123; forEach, map, filter, flatten &#125; = require(&quot;arrayUtils&quot;);","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.renpingjun.top/tags/JavaScript/"}]},{"title":"JavaScript穷理尽微-从变量的声明谈起","date":"2018-03-02T05:03:00.000Z","path":"2018/03/02/d2dj83yewq3/","text":"一 var关键字在ES5时代，我们都用var关键字来声明一个变量。语法是var操作符+变量名，例如 var message = “hello world”。但有过JavaScript编程经验的都会发现：实际上使用var是有问题的。 问题一：变量提升var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。代码示例： 123456789var name = &quot;renpingjun&quot;;var f = function()&#123; console.log(name); if (false)&#123; var name = &quot;rpj&quot;; console.log(name); &#125;&#125;f();// undefined 因为变量可以重复声明，而且ES5没有块级作用域，使得内部变量可可以覆盖外部变量。上面函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 问题二：变量可以重复声明在上一个问题里，我们提到了变量可以反复声明。理论上，在同一个作用域变量是不可以重复声明的。但在ES5中使用var语句多次声明一个变量不仅是合法的,而且也不会造成任何错误。123456var foo = function()&#123; var name = &quot;renpingjun&quot;; var name = &quot;rpj&quot;; console.log(name);&#125;foo();// rpj 问题三：变量是全局的ES5是没有块级作用域一说的，它只有全局作用域和函数作用域，关于函数作用域我会在以后章节细说，这里只说全局作用域。说到全局作用域需要提一下顶层对象，顶层对象在浏览器环境指的是window对象，在Node指的是global对象。我们使用var关键字声明的变量都是全局的，而在ES5之中，顶层对象的属性与全局变量是等价的。代码示例：12345window.title = &quot;blog&quot;;console.log(title) // blog;var title = &quot;blog&quot;;console.log(window.title) // blog; 将顶层对象的属性与全局变量视为等同是不合理的，一是因为顶层对象的属性是随处可以读写的，这非常不利于模块化编程；二是window对象有实体含义，指的是浏览器的窗口对象，与全局变量有明显的差异。 另外一个比较恰当的例子就是在for循环中，用来计数的循环变量会泄露为全局变量。 123456var str = &quot;renpingjun&quot;;for(var i = 0; i &lt; str.length; i++)&#123; console.log(str[i]);&#125;console.log(i);// 5 在示例代码中，变量i只用来控制循环，但是循环结束后它并没有消失，反而泄露成了全局变量。 二 let和const关键字为了解决ES5中var关键字声明变量的问题，ES6提出了let关键字。let的主要作用是为 JavaScript 新增了块级作用域。let的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。代码示例：123for (let i = 0; i &lt; 10; i++) &#123;&#125;console.log(i);//ReferenceError: i is not defined 示例代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 为了改变ES5中变量提升这一语法现象，let关键字改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。12console.log(name); // 报错ReferenceErrorlet name = &quot;renpingjun&quot;; let不允许在相同作用域内，重复声明同一个变量，否则报错，因此也不能在函数内部重新声明参数。示例代码：12345678910function foo()&#123; let a = 1; let a = 2; console.log(a);&#125;foo();// Uncaught SyntaxError: Identifier &apos;a&apos; has already been declaredfunction func(arg) &#123; let arg; // Uncaught SyntaxError: Identifier &apos;arg&apos; has already been declared&#125; 相比较ES5的var关键字，let关键字具有三个明显的特征： 1 let声明的变量只在它所在的代码块有效；2 let关键字改变了变量提升的的语法现象；3 在同一作用域，不允许重复声明变量。 在实际编程中，我们不仅需要变量，还需要常量。所谓常量，就是一经声明便不可修改的量。于是ES6增加了const关键字，常量一旦声明，值就不能改变，强行修改就会报错。这也就意味着，声明后就必须立即初始化，不能留到以后赋值。代码示例：12345const name = &quot;renpingjun&quot;;name = &apos;rpj&apos;; // Uncaught TypeError: Assignment to constant variable.const vm;vm = &quot;2.56&quot;; // Uncaught SyntaxError: Missing initializer in const declaration.","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.renpingjun.top/tags/JavaScript/"}]},{"title":"JavaScript穷理尽微-导读","date":"2018-03-02T02:03:00.000Z","path":"2018/03/02/ss34738dh/","text":"屈指一数，吾从事web前端开发迄今已有四载矣。心间颇多感慨，竟不知从何说起，可叹逝者如斯夫。 期间，辗转几家公司，行业各有所属：教育、电商、保险等等不一而足，然立足开发，确是编程语言始相类矣，岂独前端之JavaScript哉。 JavaScript自诞生以来便备受瞩目，不断发展，尤近两年，核心版本已逾其六，其语言本身、应用场景、框架模式皆已今非昔比，非当日JavaScript可比肩矣。 吾亦从当年切图仔趋至开发工程师之流，实乃顺时势为之，不见有语言理论体系化之作，心甚愧之。况闻近日项目无新添之事仅维护耳，趁此忙中闲暇，欲重新系统学习JavaScript，名之曰JavaScript穷理尽微。 这是JavaScript穷理尽微系列的第一篇，是为导读。 目录一. 从变量的声明谈起二. 数据类型三. 解构赋值四. 操作符五. 字符串操作…… 穷理尽微：一词出自《文选·答魏太子笺》：“发言抗论，穷理尽微”，意思是系统深入地研究事物的原理，以达到精深奥妙的境地。 学习书目：《JavaScript高级程序设计》、《精通JavaScript开发》、《ES6标准入门》、《JavaScript设计模式》 二零一八年三月二日 于北京泰康三楼","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.renpingjun.top/tags/JavaScript/"}]},{"title":"http协议面试常见问题","date":"2018-01-20T08:34:40.000Z","path":"2018/01/20/hd4q76ta/","text":"HTTP协议是互联网的基础协议，也是网页开发的必备知识。本文整理了前端面试中涉及到HTTP协议的相关问题。 一 URL详解通常一个完整的URL如下示例： 1schema://host[:port#]/path/.../[?query-string][#anchor] scheme 指定低层使用的协议(例如：http, https, ftp) host HTTP服务器的IP地址或者域名 port# HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 http://www.renpingjun.cn:9091/ path 访问资源的路径 query-string 发送给http服务器的数据 anchor- 锚 二 Get和Post方法的区别 get重点在从服务器上获取资源，post重点在向服务器发送数据； get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用”?”连接，多个请求数据间用”&amp;”连接，这个过程用户是可见的，post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的； 受URL长度限制，get传输的数据量小但效率较高，因为URL是可见的，可能会泄露私密信息；post可以传输大量数据，所以上传文件时只能用post方式，较get安全性较高； get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码,post支持标准字符集，可以正确传递中文字符. 三 常用的HTTP请求方法有哪些？ GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器。 POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。 PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。 HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。 DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。 OPTIONS：查询相应URI支持的HTTP方法。 四 常见状态码及其含义 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求 200：请求被正常处理 204：请求被受理但没有资源可以返回 301：永久性重定向 302：临时重定向 304：发送附带条件的请求时，条件不满足时返回，与重定向无关 400：请求报文语法有误，服务器无法识别 401：请求需要认证 403：请求的对应资源禁止被访问 404：服务器无法找到对应资源 500：服务器内部错误 503：服务器正忙 五 描述http从请求到响应的过程1 域名解析；2 发起tcp的3次握手；3 建立tcp连接后发起http请求；4 服务器端响应http请求，返回给客户端html代码；5 浏览器解析html代码，并请求所需资源；6 浏览器渲染页面呈现给用户。","tags":[{"name":"http","slug":"http","permalink":"http://www.renpingjun.top/tags/http/"}]},{"title":"http协议：从看懂浏览器http报文开始","date":"2018-01-18T08:34:40.000Z","path":"2018/01/18/hd4q76ta/","text":"HTTP协议是WWW服务器和用户请求代理（浏览器）之间通过应答请求模式传输超文本内容（html、css、js、图片、接口数据等）的一种协议。 HTTP协议经过了从1.0到2.0的发展，HTTP2相比较与HTTP1有以下几个明显的优点： 采用二进制格式传输数据 使用TCP多路复用的方式来降低网络请求开销 支持传输流的优先级和流量控制机制 支持服务器端推送 通常一个完整的HTTP报文由头部、空行、正文三部分组成。HTTP报文的头部域信息内容有很多，如下图所示： 以谷歌浏览器为例，通过开发者工具可以看到，一个完整的HTTP请求包含General（基本信息）,Request Headers（请求头）,Query String Parameters（请求参数）,Response Headers（响应头）,Response Body（响应体）五部分，每个字段都有自己的逻辑和判断机制，现在我们对一些常见的字段设置作详细解释1234567891011121314151617181920212223242526272829303132333435Request URL:请求路径，通常包含协议、域名、端口号、访问资源路径和请求参数·Request Method:请求方法，比如Get、Post、Put等·Status Code:请求返回的状态码，比如304、200等·Remote Address:请求远端地址·Referrer Policy:主要用作分析用户来源，新的Referrer Policy规定了五种 Referrer 策略：No Referrer、No Referrer When Downgrade、Origin Only、Origin When Cross-origin、和 Unsafe URL-------------------------------User-agent:客户端（浏览器）信息·Cookie:站点cookie信息，可在客户端和服务端之间来回传递·Accept:浏览器接收媒体资源类型，*/*表示所有类型；一般有text/plain,text/html,application/json等等·Accept-Charset:浏览器接收内容字符集，一般是utf-8·Accept-Encoding:浏览器接收内容的编码方法，如指定是否支持压缩、压缩的方法，一般有gzip,deflate,sdch·Accept-language:浏览器接收内容的语言，一般有zh-CN,en等·Allow:设置服务端支持接收哪些HTTP请求方法，如get,post,put等，如果不支持则返回405(Method Not Allowed)·Authorization:授权信息，当客户端接收到来自服务器的WWW-Authenticate响应时，可以用该头部的身份验证信息给web服务器进行认证,比如说Bearer token认证·Cache-Control:服务器缓存控制指令。no-cache表示不使用缓存，要求从服务器请求内容；max-age表示只接受Age值小于max-age的内容，即没有过期的请求对象-----------------------content-length:声明本次回应的数据长度·Expires:web服务器表明该实体在什么时候过期·Server:服务器名称信息，比如Nginx、Openrestry等·Content-Type:web服务器响应的类型，与Accept对应 浏览器发起请求时，会根据头部域字段进行判断是否进行缓存读取，大致流程如下图：","tags":[{"name":"http","slug":"http","permalink":"http://www.renpingjun.top/tags/http/"}]},{"title":"JavaScript正则表达式匹配汉字","date":"2017-10-18T12:03:00.000Z","path":"2017/10/18/h473djdgs/","text":"一 正则汉字匹配现状在谷歌搜索「JavaScript 正则表达式匹配汉字」的时候，前几条结果全都是 /[\\u4e00-\\u9fa5]/。没有人怀疑这个正则表达式有什么问题，那么在 2018 年的今天，让我们站在 Chrome 64 的肩膀上，放飞一下自我。 汉文（Han Script）是汉语、日本语、朝鲜语、韩国语的书写系统中的一种文字（Script），越南语在早期也曾在书写系统中使用汉文[1]。汉字（CJK Ideograph）是汉文的基本单元。各国都对汉字提出了自己的编码标准，Unicode 将这些标准加总在一起进行统一编码，力求实现原标准与 Unicode 编码之间的无损转换。Unicode 从语义（semantic）、抽象字形（abstract shape），具体字形（typeface）三个维度[2]出发，把不同编码标准里「起源相同、本义相同、形状一样或稍异」的汉字赋予相同编码，这些被编码的字符称为中日韩统一表意文字（下文我们提到的「汉字」，如果不加说明，均指代中日韩统一表意文字）。如果把它们全部列举出来写成正则表达式，那么就是技术上完整的匹配汉字的正则表达式了。 正则表达式 /[\\u4e00-\\u9fa5]/的意思是匹配所有从 U+4E00, cjk unified ideograph-4e00 到 U+9FA5, cjk unified ideograph-9fa5 的字符。这一段区域对应的是 Unicode 1.0.1 就收录进来的中日韩统一表意文字（CJK Unified Ideographs）区块，在 Unicode 3.0 加入扩展 A 区以前，这个正则表达式确实给出了所有汉字的编码。换言之，从1992年到1999年，这个正则表达式确实是正确的，想必这个表达式已经有20年历史了。 二 匹配所有统一表意文字然而时光飞逝，Unicode 在2017年6月发布了10.0.0版本。在这20年间，Unicode 添加了许多汉字。比如 Unicode 8.0 添加的 109 号化学元素「鿏（⿰⻐麦）」，其码点是 9FCF，不在这个正则表达式范围中。而如果我们期望程序里的 /[\\u4e00-\\u9fa5]/可以与时俱进匹配最新的 Unicode 标准，显然是不现实的事情。因此，我们需要换一个思路，写一个无需维护的正则表达式：1/\\p&#123;Unified_Ideograph&#125;/u 其中 \\u是 ECMAScript 2015 定义的正则表达式标志，意味着将表达式作为 Unicode 码点序列。 \\p是正在提案阶段的正则表达式 Unicode 属性转义，它赋予了我们根据 Unicode 字符的属性数据[3]构造表达式的能力。 Unified_Ideograph是 Unicode 字符的一个二值属性，对于汉字，其取值为 Yes，否则为 No。因此\\p{Unified_Ideograph}匹配所有满足 Unified_Ideograph=yes的 Unicode 字符，而它的底层实现由运行时所依赖的 Unicode 版本决定，开发者不需要知道汉字的具体 Unicode 码点范围。 三 容易混淆的其他 Unicode 属性转义表达式1/\\p&#123;Ideographic&#125;/u 这个表达式匹配所有满足 Ideographic=yes的 Unicode 字符。我们先看一下 UAX #44 对这个属性的解释： Characters considered to be CJKV (Chinese, Japanese, Korean, and Vietnamese) or other siniform (Chinese writing-related) ideographs. This property roughly defines the class of “Chinese characters” and does not include characters of other logographic scripts such as Cuneiform or Egyptian Hieroglyphs. 这个属性表明该字符属于 CJKV 表意文字或者与汉语书写相关的其他表意文字（如西夏文、女书），这个属性粗略地定义了「中文字符」的分类。 四 浏览器兼容性支持截至2018年1月，只有 Chrome 64 支持正则表达式 Unicode 属性转义。对于其他浏览器，我们需要用 babel转译插件@babel/plugin-proposal-unicode-property-regex的底层将带有属性转义的正则表达式转为 Unicode 码点正则表达式或者 ES 5 的正则表达式。转译结果的在线演示可以在这里查看，用户可以自己在上面转译其他的 Unicode 属性转义正则表达式。我们在这里列举 /\\p{Unified_Ideograph}/u转译成Unicode 码点正则表达式的结果： 123const regex = /\\p&#123;Unified_Ideograph&#125;/u;// transpiled to ES6:const regex =/[\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uFA0E\\uFA0F\\uFA11\\uFA13\\uFA14\\uFA1F\\uFA21\\uFA23\\uFA24\\uFA27-\\uFA29\\u&#123;20000&#125;-\\u&#123;2A6D6&#125;\\u&#123;2A700&#125;-\\u&#123;2B734&#125;\\u&#123;2B740&#125;-\\u&#123;2B81D&#125;\\u&#123;2B820&#125;-\\u&#123;2CEA1&#125;\\u&#123;2CEB0&#125;-\\u&#123;2EBE0&#125;]/u; 该插件还可以使用:12345&#123; &quot;plugins&quot;: [ [&quot;@babel/plugin-proposal-unicode-property-regex&quot;, &#123; &quot;useUnicodeFlag&quot;: false &#125;] ]&#125; 配置将表达式转成 ES5 的传统的以字符的 UTF16 表示为序列的字符串，这里不再赘述。 input 元素的 pattern 属性 在前端技术中，除了JavaScript会用到正则表达式，HTML 里元素的pattern属性也会用到正则表达式。与 JavaScript 相比，pattern不支持设置正则表达式的标志位，因此 HTML 标准中强制规定了 input 元素的 pattern 属性需要施加unicode标志 [6]。目前只有 Chrome 53+, Firefox 遵循了这一标准，其他的浏览器暂未支持。 在 React/Angular/Vue.js 三大前端框架中，Angular 提供了近似于 pattern 的指令 ngPattern。目前ngPattern尚未施加unicode标志 [7]。AngularJS 的 ngPattern directive 仍未施加。 在大部分情况，是否施加unicode标志不会对正则表达式产生语义区别。主要的差别在于，在使用\\u{10000}表示 Unicode 码点字符情形，正则表达式/\\u{10000}/代表匹配u一万次，/\\u{10000}/u匹配字符\\u{10000}一次；/./只匹配 BMP 平面的字符，/./u匹配所有平面的字符。 由于 Unicode 属性转义正则表达式依赖于标识位\\u，因此下面的用法目前只能在 Chrome 下使用： 1&lt;input type=&quot;text&quot; pattern=&quot;\\p&#123;Unified_Ideograph&#125;&quot;&gt; 因此，如果需要兼容其他浏览器，可以使用转译插件的底层库regexpu-core在 js 层转换正则表达式，再把转换结果输送到 HTML 模版中。 123456const rewritePattern = require(&quot;regexpu-core&quot;);rewritePattern(&apos;\\\\p&#123;Unified_Ideograph&#125;&apos;, &apos;u&apos;, &#123; &apos;unicodePropertyEscape&apos;: true, &apos;useUnicodeFlag&apos;: false&#125;);// → &apos;/(?:[\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uFA0E\\uFA0F\\uFA11\\uFA13\\uFA14\\uFA1F\\uFA21\\uFA23\\uFA24\\uFA27-\\uFA29]|[\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0])/&apos; 五 总结 /[\\u4e00-\\u9fa5]/是错的，不要用二十年前的正则表达式了。 /\\p{Unified_Ideograph}/u是正确的，不需要维护，匹配所有汉字。这里\\p是 Unicode 属性转义正则表达式。 /\\p{Ideographic}/u 和 /\\p{Script=Han}/u 匹配了除了汉字以外的其他一些字符，在「汉字匹配正则表达式」这个需求下，是错的。 目前只有 Chrome 支持 Unicode 属性转义正则表达式。对其他环境，使用@babel/plugin-proposal-unicode-property-regex 和 regexpu-core 进行优雅降级。 阅读原文：https://qianduan.group/posts/5a6ede120cf6b624d2239c8b","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://www.renpingjun.top/tags/正则表达式/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.renpingjun.top/tags/JavaScript/"}]},{"title":"JavaScript正则表达式匹配身份证号码","date":"2017-10-17T12:03:00.000Z","path":"2017/10/17/1f35839j/","text":"我们先来看一段正则代码:1/(^\\d&#123;15&#125;$)|(^\\d&#123;17&#125;([0-9]|X)$)/ 非常眼熟对不对，这是长时间以来我们匹配身份证号码用的正则表达式，而且在google、百度搜索“身份证 正则”等相关关键字时，无一例外结果都是这个答案。 这段代码验证的情况有两种，一种是15位数字，一种是18位（17位数字+1位数字或“X”），好像没有什么问题，但细究起来其实是不严谨的。比如说“123456789012345”是可以通过这个正则验证的，但它却不是一个身份证号码。 无论是15位还是18位，身份证号码都有一套自己的编码规则，我们只要循着规则，不难写出正确（严谨）的身份证号码正则表达式。 一 从身份证号码编码规则说起1 15位身份证号码编码规则15位身份证号码是新中国第一代身份证号码，格式如：ABCDEFYYYYMMDDX 地址码（ABCDEF）表示登记户口时所在地的行政区划代码（省、市、县），如果行政区划进行了重新划分，同一个地方进行户口登记的可能存在地址码不一致的情况。行政区划代码按GB/T2260的规定执行。 出生日期码（YYYYMMDD）表示该居民的出生年月日，年4位数字，月和日分别用2位数字表示，如19491001，；出生日期码是按GB/T 7408的规定执行的。 顺序码（X）表示同一地址码区域内，同年、同月、同日生的人所编订的顺序号，根据自己身份证的顺序码就可以知道：与我们同年同月同日生的同性至少有多少个，且在我们之前登记户籍的有多少人。身份证顺序码的奇数分配给男性，偶数分配给女性。这就是为什么倒数第二位奇数表示男生，偶数表示女生。 2 18位身份证号码编码规则1999年我国颁发了第二代居民身份证号，公民身份号码为18位，且终身不变。居民身份证格式如：ABCDEFYYYYMMDDXXXR 同15位的差别在于顺序码加到了3位，并且增加了校验码（R），R之前的17位被称为本体码，R是根据本体码，按照校验码算法(ISO 7064:1983,MOD 11-2校)计算出来的。当我们输入身份号码进行实名认证的时候，根据校验码算法可以初步判断你输入身份证号码格式是否正确。 校验码（R）的算法是：将本体码各位数字乘以对应加权因子并求和，除以11得到余数，根据余数通过校验码对照表查得校验码。 加权因子 位置序号 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 加权因子 7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2 校验码表 余数 0 1 2 3 4 5 6 7 8 9 10 校验码 1 0 X 9 8 7 6 5 4 3 2 3 应用举例某公民的身份证号码是34052419800101001X， 1 本体码乘以加权因子： 13*7+4*9+0*10+……0*4+1*2=189 2 计算求和后除以11的余数 1189%11=2 3 在检验码中查询余数对应的检验码 余数2所对应的校验码是X，注意X必须大写 二 正则表达式匹配身份证号码清楚了身份证号码的编码规则，再根据规则写出正则表达式就简单了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889const isCardNo = (value) =&gt; &#123; //验证身份证号方法 let area = &#123; 11: &quot;北京&quot;, 12: &quot;天津&quot;, 13: &quot;河北&quot;, 14: &quot;山西&quot;, 15: &quot;内蒙古&quot;, 21: &quot;辽宁&quot;, 22: &quot;吉林&quot;, 23: &quot;黑龙江&quot;, 31: &quot;上海&quot;, 32: &quot;江苏&quot;, 33: &quot;浙江&quot;, 34: &quot;安徽&quot;, 35: &quot;福建&quot;, 36: &quot;江西&quot;, 37: &quot;山东&quot;, 41: &quot;河南&quot;, 42: &quot;湖北&quot;, 43: &quot;湖南&quot;, 44: &quot;广东&quot;, 45: &quot;广西&quot;, 46: &quot;海南&quot;, 50: &quot;重庆&quot;, 51: &quot;四川&quot;, 52: &quot;贵州&quot;, 53: &quot;云南&quot;, 54: &quot;西藏&quot;, 61: &quot;陕西&quot;, 62: &quot;甘肃&quot;, 63: &quot;青海&quot;, 64: &quot;宁夏&quot;, 65: &quot;新疆&quot;, 71: &quot;台湾&quot;, 81: &quot;香港&quot;, 82: &quot;澳门&quot;, 91: &quot;国外&quot; &#125; let idcard, Y, JYM; let idcard = value.toString(); let S, M; let idcard_array = new Array(); idcard_array = idcard.split(&quot;&quot;); if(area[parseInt(idcard.substr(0, 2))] == null) return false; switch(idcard.length) &#123; case 15: if((parseInt(idcard.substr(6, 2)) + 1900) % 4 == 0 || ((parseInt(idcard.substr(6, 2)) + 1900) % 100 == 0 &amp;&amp; (parseInt(idcard.substr(6, 2)) + 1900) % 4 == 0)) &#123; ereg = /^[1-9][0-9]&#123;5&#125;[0-9]&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))[0-9]&#123;3&#125;$/; //测试出生日期的合法性 &#125; else &#123; ereg = /^[1-9][0-9]&#123;5&#125;[0-9]&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|1[0-9]|2[0-8]))[0-9]&#123;3&#125;$/; //测试出生日期的合法性 &#125; if(ereg.test(idcard)) //return Errors[0]; let res = true; else //return Errors[2]; let res = false; return res; break; case 18: if(parseInt(idcard.substr(6, 4)) % 4 == 0 || (parseInt(idcard.substr(6, 4)) % 100 == 0 &amp;&amp; parseInt(idcard.substr(6, 4)) % 4 == 0)) &#123; ereg = /^[1-9][0-9]&#123;5&#125;[1-2][0-9][0-9]&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))[0-9]&#123;3&#125;[0-9Xx]$/; //闰年出生日期的合法性正则表达式 &#125; else &#123; ereg = /^[1-9][0-9]&#123;5&#125;[1-2][0-9][0-9]&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|1[0-9]|2[0-8]))[0-9]&#123;3&#125;[0-9Xx]$/; //平年出生日期的合法性正则表达式 &#125; if(ereg.test(idcard)) &#123; S = (parseInt(idcard_array[0]) + parseInt(idcard_array[10])) * 7 + (parseInt(idcard_array[1]) + parseInt(idcard_array[11])) * 9 + (parseInt(idcard_array[2]) + parseInt(idcard_array[12])) * 10 + (parseInt(idcard_array[3]) + parseInt(idcard_array[13])) * 5 + (parseInt(idcard_array[4]) + parseInt(idcard_array[14])) * 8 + (parseInt(idcard_array[5]) + parseInt(idcard_array[15])) * 4 + (parseInt(idcard_array[6]) + parseInt(idcard_array[16])) * 2 + parseInt(idcard_array[7]) * 1 + parseInt(idcard_array[8]) * 6 + parseInt(idcard_array[9]) * 3; Y = S % 11; M = &quot;F&quot;; JYM = &quot;10X98765432&quot;; M = JYM.substr(Y, 1); if(M == idcard_array[17]) //return Errors[0]; let res = true; else //return Errors[3]; let res = false; &#125; else //return Errors[2]; res = false; return res; break; default: res = false; return res; break; &#125;;&#125;","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://www.renpingjun.top/tags/正则表达式/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.renpingjun.top/tags/JavaScript/"}]},{"title":"MYSQL 基本操作指南","date":"2017-04-29T08:59:00.000Z","path":"2017/04/29/c19517s2/","text":"环境：Linux Ubuntu14.04, MYSQL5.5 1.登录数据库服务器1234567mysql -u root -p (默认端口3306)·mysql -u root -p --protocol=tcp --host=localhost --port=3307 （通过tcp连接管理不同端口的MYSQL）·mysql -u root -p --socket=/tmp/mysql3307.sock （通过socket套接字连接管理不同端口的MYSQL）·mysql -u root -p 3306 -h 127.0.0.1 （通过端口和IP管理不同端口的MYSQL） 2.数据库操作123456789SHOW DATABASES; （显示所有数据库）·CREATE DATABASE vue_ghs; （创建一个名为vue_ghs的数据库）·DROP DATABASE vue_ghs; （删除数据库）·USE vue_ghs; （选择将要操作的数据库）·SOURCE vue_ghs.sql; （MYSQL导入.sql文件） 3.表操作12345678910111213141516171819202122SHOW TABLES; （显示所有数据表）·CREATE TABLE `renpingjun` ( `id` INT( 5 ) UNSIGNED NOT NULL AUTO_INCREMENT , `username` VARCHAR( 20 ) NOT NULL , `password` CHAR( 32 ) NOT NULL , `time` DATETIME NOT NULL , `number` FLOAT( 10 ) NOT NULL , `content` TEXT NOT NULL , PRIMARY KEY ( `id` ) ) ENGINE = MYISAM ; （创建数据表renpingjun：在mysql&gt;后粘贴以下SQL语句，存储引擎为MYISAM，字段id为主键、唯一索引）·DESCRIBE renpingjun; （查看renpingjun数据表结构）·SELECT * FROM renpingjun; （从renpingjun数据表中检索所有记录）·SELECT * FROM renpingjun WHERE username = abc AND number=1 ORDER BY id DESC; （从renpingjun数据表中检索username = abc AND number=1的记录，按字段id降序排序）·INSERT INTO renpingjun (id, username, password, time, number, content) VALUES (, abc, 123456,2017-04-29 14:32:12, 23.41, hello world); （插入信息到renpingjun数据表）·UPDATE renpingjun SET content = hello china WHERE username = abc; （更新数据表信息）·UPDATE renpingjun SET content = REPLACE (content, aaa, bbb); （批量替换renpingjun数据表中content字段中的“aaa”为“bbb”）·DELETE FROM renpingjun; （清空renpingjun数据表）·DROP TABLE renpingjun; （删除renpingjun数据表）·REPAIR TABLE renpingjun; （修复损坏的renpingjun数据表） 4.数据库权限操作1234567GRANT ALL PRIVILEGES ON *.* TO renpingjun@% IDENTIFIED BY 123456; （创建一个具有root权限，可从任何IP登录的用户renpingjun，密码为123456）·GRANT SELECT , INSERT , UPDATE , DELETE , FILE , CREATE , DROP , INDEX , ALTER , CREATETEMPORARY TABLES , CREATE VIEW , SHOW VIEW , CREATE ROUTINE, ALTER ROUTINE, EXECUTE ON*.* TO xiawei@192.168.1.% IDENTIFIED BY 123456; （创建一个具有数据操作、结构操作权限，只能从IP为192.168.1登录的用户xiawei,密码为123456）·DROP USER xiawei@%; （删除用户xiawei） 5.登出数据库服务器1exit;","tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.renpingjun.top/tags/mysql/"}]},{"title":"Git面试问题详解","date":"2016-11-15T11:48:00.000Z","path":"2016/11/15/g1953e22/","text":"1 Gitflow工作流程git关键分支：master 主分支；develop 主开发分支，包含确定即将发布的代码；feature 新功能分支，一般一个新功能对应一个分支，对于功能的拆分需要比较合理，以避免一些后面不必要的代码冲突；release 发布分支，发布时候用的分支，一般测试时候发现的 bug 在这个分支进行修复；hotfix hotfix 分支，紧急修 bug 的时候用。 分支关系：feature 分支都是从 develop 分支创建，完成后再合并到 develop 分支上，等待发布；当需要发布时，我们从 develop 分支创建一个 release 分支，然后这个 release 分支会发布到测试环境进行测试，如果发现问题就在这个分支直接进行修复。在所有问题修复之前，我们会不停的重复发布-&gt;测试-&gt;修复-&gt;重新发布-&gt;重新测试这个流程。发布结束后，这个 release 分支会合并到 develop 和 master 分支，从而保证不会有代码丢失；master 分支只跟踪已经发布的代码，合并到 master 上的 commit 只能来自 release 分支和 hotfix 分支；hotfix 分支的作用是紧急修复一些 Bug，它们都是从 master 分支上的某个 tag 建立，修复结束后再合并到 develop 和 master 分支上； 2 GitFlow 的优势： 并行开发：GitFlow 可以很方便的实现并行开发：每个新功能都会建立一个新的 feature 分支，从而和已经完成的功能隔离开来，而且只有在新功能完成开发的情况下，其对应的 feature 分支才会合并到主开发分支上（也就是我们经常说的 develop 分支）。另外，如果你正在开发某个功能，同时又有一个新的功能需要开发，你只需要提交当前 feature 的代码，然后创建另外一个 feature 分支并完成新功能开发。然后再切回之前的 feature 分支即可继续完成之前功能的开发。 协作开发：GitFlow 还支持多人协同开发，因为每个 feature 分支上改动的代码都只是为了让某个新的 feature 可以独立运行。同时我们也很容易知道每个人都在做什么。 发布阶段：当一个新 feature 开发完成的时候，它会被合并到 develop 分支，这个分支主要用来暂时保存那些还没有发布的内容，所以如果需要再开发新的 feature，我们只需要从 develop 分支创建新分支，即可包含所有已经完成的 feature 。 支持紧急修复：GitFlow 还包含了 hotfix 分支。这种类型的分支是从某个已经发布的 tag 上创建出来并做一个紧急的修复，而且这个紧急修复只影响这个已经发布的 tag，而不会影响到你正在开发的新 feature。 3 Git仓库组成部分及其相互之间的转换关系 git仓库由三个部分组成：工作区（Working Directory）、暂存区（Stage）和历史记录区（History）。 工作区：在 git 管理下的正常目录都算是工作区，我们平时的编辑工作都是在工作区完成。 暂存区：也就是临时区域，里面存放将要提交文件的快照。 历史记录区：git commit 后的记录区。 三个区的转换关系以及转换所使用的命令： 4 git reset、git revert 和 git checkout 有什么区别git reset 可以将一个分支的末端指向之前的一个 commit。然后再下次 git 执行垃圾回收的时候，会把这个 commit 之后的 commit 都扔掉。git reset 还支持三种标记，用来标记 reset 指令影响的范围：（1）–mixed：会影响到暂存区和历史记录区。也是默认选项；（2）–soft：只影响历史记录区；（3）–hard：影响工作区、暂存区和历史记录区。 git checkout 可以将 HEAD 移到一个新的分支，并更新工作目录。因为可能会覆盖本地的修改，所以执行这个指令之前，你需要 stash 或者 commit 暂存区和工作区的更改。 git revert 和 git reset 的目的是一样的，但是做法不同，它会以创建新的 commit 的方式来撤销 commit，这样能保留之前的 commit 历史，比较安全。另外，同样因为可能会覆盖本地的修改，所以执行这个指令之前，你需要 stash 或者 commit 暂存区和工作区的更改。","tags":[{"name":"Git","slug":"Git","permalink":"http://www.renpingjun.top/tags/Git/"}]},{"title":"Git工作流程","date":"2016-11-14T12:34:00.000Z","path":"2016/11/14/g19527sq/","text":"引子Git作为一个分布式版本控制系统，通常会涉及到多人协作。而协作必须有一个规范的工作流程，让大家有效地合作，使得项目井井有条地发展下去。”工作流程”在英语里，叫做”workflow”或者”flow”，意思就是项目像水流那样，顺畅、自然地向前流动，不会发生冲击、对撞、甚至漩涡。本文介绍三种广泛使用的工作流程： Git flow Github flow Gitlab flow 一 Git flowGit flow是最早诞生、并得到广泛采用的一种工作流程，详细介绍参考：A successful Git branching model 在Git flow 流中，项目存在两个长期分支，即主分支master和开发分支develop，前者用于存放对外发布的版本，任何时候在这个分支拿到的，都是稳定的分布版；后者用于日常开发，存放最新的开发版。同时项目存在三种短期分支（非必需），即功能分支（feature branch）、补丁分支（hotfix branch）、预发分支（release branch）。 二 Github flowGithub flow 是 Github.com 使用的工作流程，是Git flow的简化版，专门配合”持续发布”。它只有一个长期分支，就是master，因此用起来非常简单。官方推荐流程如下，详情参见：Understanding the GitHub Flow 1：根据需求，从master拉出新分支，不区分功能分支或补丁分支。 2：新分支开发完成后，或者需要讨论的时候，就向master发起一个pull request（简称PR）。 3：Pull Request既是一个通知，让别人注意到你的请求，又是一种对话机制，大家一起评审和讨论你的代码。对话过程中，你还可以不断提交代码。 4：你的Pull Request被接受，合并进master，重新部署后，原来你拉出来的那个分支就被删除。（先部署再合并也可。） 三 Gitlab flowGitlab flow 吸取了Git flow 与 Github flow的优点，既有适应不同开发环境的弹性，又有单一主分支的简单和便利。它是 Gitlab.com 推荐的做法。Gitlab flow 的最大原则叫做”上游优先”（upstream first），即只存在一个主分支master，它是所有其他分支的”上游”。只有上游分支采纳的代码变化，才能应用到其他分支。 对于”持续发布”的项目，它建议在master分支以外，再建立不同的环境分支。比如，”开发环境”的分支是master，”预发环境”的分支是pre-production，”生产环境”的分支是production。开发分支是预发分支的”上游”，预发分支又是生产分支的”上游”。代码的变化，必须由”上游”向”下游”发展。比如，生产环境出现了bug，这时就要新建一个功能分支，先把它合并到master，确认没有问题，再cherry-pick到pre-production，这一步也没有问题，才进入production。只有紧急情况，才允许跳过上游，直接合并到下游分支。 对于”版本发布”的项目，建议的做法是每一个稳定版本，都要从master分支拉出一个分支，比如2-3-stable、2-4-stable等等。以后，只有修补bug，才允许将代码合并到这些分支，并且此时要更新小版本号。 四 其他1 Pull Request功能分支合并进master分支，必须通过Pull Request（Gitlab里面叫做 Merge Request）； 2 Protected branchmaster分支应该受到保护，不是每个人都可以修改这个分支，以及拥有审批 Pull Request 的权力。Github 和 Gitlab 都提供”保护分支”（Protected branch）这个功能。 3 IssueIssue 用于 Bug追踪和需求管理。建议先新建 Issue，再新建对应的功能分支。功能分支总是为了解决一个或多个 Issue。功能分支的名称，可以与issue的名字保持一致，并且以issue的编号起首，比如”15-require-a-password-to-change-it”。 4 Merge节点Git有两种合并：一种是”直进式合并”（fast forward），不生成单独的合并节点；另一种是”非直进式合并”（none fast-forward），会生成单独节点。前者不利于保持commit信息的清晰，也不利于以后的回滚，建议总是采用后者（即使用–no-ff参数）。只要发生合并，就要有一个单独的合并节点。 5 Squash 多个commit为了便于他人阅读你的提交，也便于cherry-pick或撤销代码变化，在发起Pull Request之前，应该把多个commit合并成一个。（前提是，该分支只有你一个人开发，且没有跟master合并过。）这可以采用rebase命令附带的squash操作。","tags":[{"name":"Git","slug":"Git","permalink":"http://www.renpingjun.top/tags/Git/"}]},{"title":"Git基本使用指南","date":"2016-11-13T11:48:00.000Z","path":"2016/11/13/g19527s2/","text":"引子在团队项目开发里，经常会遇到一个项目由多人通力合作完成的情况，每个人负责其中一个模块，开发过程中为了确保代码追本溯源，我们引入了版本控制概念，每个人修改了什么代码或提交了什么代码都能够跟踪记录。现在流行的版本控制主要有：集中式版本控制（Svn）和分布式版本控制（Git）。Git由于其分布式开发，速度快、使用灵活，为大多数开发者所青睐。本文将介绍Git的基本使用方法。 一 初始化Git仓库Git仓库分为两种类型：一种是存放在服务器上面的空仓库（也称裸仓库），里面没有保存文件，只是存放.git的内容；一种是标准仓库，会在项目根目录下创建一个.git目录。 1234$ git init &lt;project_name&gt; # 创建标准仓库，在项目根目录下创建一个隐藏的.git# 文件夹$ git init --bare &lt;project_name&gt; # 创建一个裸仓库，裸仓库只有.git目录内容，# 而没有工作区域，一般用于在共享服务器上面创建。 二 查看当前Git配置Git配置信息分成三个级别，分别存放在三个不同的地方： 一个是系统级别的配置文件，系统基本配置文件存放在Git的安装目录中； 一个是用户级别配置文件，用户级别配置文件存放在当前用户目录下的.gitconfig文件内； 一个是项目级别配置文件，项目级别的配置文件会存放在.git目录的config文件中。使用git config –list显示的Git配置信息，是从系统级配置•用户级配置•项目级配置一层层叠加显示出来的，当遇到同项不同内容时以低级的配置为准。 1234567$ git config --list # 显示当前Git配置信息$ git config --system --list # 显示系统级别Git配置信息$ cat .git/config # 显示项目配置文件$ cat ~/.gitconfig # 显示用户级别配置信息 三 配置当前用户名和邮箱用Git进行版本控制与集中式版本控制不同，集中版本控制需要验证用户信息后才能提交代码，这样可以识别出谁提交了代码；而分布式版本控制的所有文件都保存在本地磁盘中，当提交代码的时候，需要配置一个用户信息才能被Git执行，在团体合作开发的时候用于识别文件是谁提交的。 12$ git config --global user.name &quot;用户名&quot; # 在用户级配置上设置用户名$ git config --global user.email &quot;用户邮箱&quot; # 在用户级配置上设置邮箱 四 克隆仓库克隆仓库是从远程服务器上拉取一个完整的仓库到本地磁盘，这样做的好处在于每个人都有一个完整的代码库，避免把鸡蛋放在同一个篮子里。但相对的，每个人都有一个完整仓库，对代码的防泄露又是一个问题。Git支持URL传输协议：本地协议（Local）、HTTP 协议、SSH（Secure Shell）协议、FTP协议、Git 协议。 1$ git clone &lt;url&gt; # 从一个远程Git仓库中克隆到本地磁盘 五 查看文件状态使用git status可以查看当前工作区域内文件的状态，没被跟踪内容会在Untracked files中显示，可以通过git add 添加被跟踪。1$ git status 六 添加文件追踪使用git add 命令将文件添加到index（索引）文件中，这些文件列表将在下一次提交时记录到仓库。1$ git add renpingjun/ # 将renpingjun目录添加到index文件中 七 提交代码使用git commit命令将index文件中的更改记录提交到本地版本库。使用参数-m可以直接将要添加的备注信息写入。1$ git commit -m &quot;add app folder&quot; # 提交到版本库，并写入提交信息 八 查看远程仓库使用git remote命令可以显示当前版本库的远程仓库服务器信息。参数-v显示远程仓库简写名称和URL地址。1$ git remote -v # 显示版本库连接的远程仓库和URL 九 添加远程仓库使用git remote add &lt;远程仓库别名&gt; 为本地版本库添加一个远程仓库。1$ git remote add origin https://github.com/rpjltx/node-practice.git # 添加一个远程仓库 十 推送代码使用git push &lt;远程仓库别名&gt; &lt;本地分支&gt;将本地版本库推送到远程仓库。1$ git push origin master # 将本地master分支提交到别名为origin的远程仓库 十一 从远程仓库更新代码到本地将代码推送到远程仓库后，其他非最新版本的用户需要更新最新代码，可以使用git fetch或git pull命令来更新。区别在于fetch获取最新的代码到本地仓库，但不会自动合并分支，需要比较分支差异后合并，而pull则直接将远程仓库的版本合并到本地master上，所以git fetch相对安全些。12$ git fetch origin master # 下载origin最新的代码$ git merge origin/master # 将origin/master分支合并到本地master中 十二 版本标记有些老师会把版本标记翻译成里程碑，即给当前提交定义一个标签，标记出当前提交内容有别于其他提交。例如，在开发完一个新功能后，可以将其标记一个v1.1，代表这个功能开发完成，方便以后历史中定位这次提交。 Git有两种标签类型：一种是lightweight轻量级标签，只有版本号无其他信息；另一种是annotated附注标签，标签附带一条信息，可以让别人快速识别标签作用，建议使用这种标签。 使用git tag -n[数字] 显示当前分支下的标签信息，参数-n代表显示备注信息行数。使用git tag -a &lt;版本号&gt; -m“备注”为最新提交打上标签。使用git show &lt;版本号&gt;显示对应标签的版本信息和提交差异。 十三 添加忽略文件在当前项目根目录下创建一个.gitignore文件，用于保存忽略列表。配置语法如下： “/”代表目录； “*”代表通配任意字符； “？”代表通配单个字符； “[]”代表单个字符的匹配列表； “！”表示不忽略，一定要跟踪。 十四 查看当前处在的分支使用命令 git branch可以查看当前工作目录所在的分支。 十五 创建分支使用命令git checkout -b rpj创建并切换到rpj分支，命令git checkout -b等同于同时执行了命令git branch rpj 创建分支和命令git checkout rpj切换到rpj分支 十六 合并分支使用命令git merge合并两个分支。 十七 解决冲突之前使用了不同的忽略语句，两个分支间没有冲突，但是如果两个分支同时修改了同一个文件相同位置的不同参数时，在合并的时候就会产生冲突。人工修改冲突部分，需要将自动生成的&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD、=======、&gt;&gt;&gt;&gt;&gt;&gt;&gt; jsb全部删除，自行判断冲突部分需要保留什么内容或者将两者融合，修改完成后保存文件，重新使用命令git add添加文件，后再提交一次，即可解决冲突问题。","tags":[{"name":"Git","slug":"Git","permalink":"http://www.renpingjun.top/tags/Git/"}]},{"title":"Linux命令学习：压缩与打包","date":"2016-10-19T12:03:00.000Z","path":"2016/10/19/l3sw4haqz/","text":"首先明确我们见到的压缩包分成两种：1，打包 即将分散的文件合并为一个文件，这在存储，传输中都是极为有利的。（如某源代码有成千的源文件，在复制、网络传递过程中需要每个文件单独发起。可以复制相同大小的压缩包和零散文件的文件夹对比一下时间）2，压缩 即通过各种算法减小打包文件的总大小，减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。 Linux 底下有很多压缩文件名，常见的如下： 扩展名 压缩程序 *.Z compress *.zip zip *.gz gzip *.bz2 bzip2 *.xz xz *.tar tar 程序打包的数据，没有经过压缩 *.tar.gz tar 程序打包的文件，经过 gzip 的压缩 *.tar.bz2 tar 程序打包的文件，经过 bzip2 的压缩 *.tar.xz tar 程序打包的文件，经过 xz 的压缩 一 tartar命令可以用来压缩打包单文件、多个文件、单个目录、多个目录。常用命令如下： 123456tar czvf my.tar file1 单个文件压缩打包tar czvf my.tar file1 file2,... 多个文件压缩打包tar czvf my.tar dir1 单个目录压缩打包tar czvf my.tar dir1 dir2 多个目录压缩打包tar xzvf my.tar 解包至当前目录 下面是常用参数解释，其他参数请参考文档12345678z ：使用 zip-j ：使用 bzip2-J ：使用 xz-c ：新建打包文件-t ：查看打包文件里面有哪些文件-x ：解打包或解压缩的功能-v ：在压缩/解压缩的过程中，显示正在处理的文件名-f ：使用档名（注意： f 之后要立即接档名，不能接参数，例 tar -zcvPf tfile sfile） 二 gzipgzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件，经过 gzip 压缩过，源文件就不存在了。123456gzip filename-c ：将压缩的数据输出到屏幕上-d ：解压缩-t ：检验压缩文件是否出错-v ：显示压缩比等信息-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6 三 bzip2提供比 gzip 更高的压缩比。 查看命令：bzcat、bzmore、bzless、bzgrep.12bzip2 filename-k ：保留源文件 四 xzxz提供比 bzip2 更佳的压缩比。查看命令：xzcat、xzmore、xzless、xzgrep.1xz filename","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.renpingjun.top/tags/Linux/"}]},{"title":"Linux命令学习：find用法示例","date":"2016-10-18T12:03:00.000Z","path":"2016/10/18/l344heua/","text":"Linux系统中的 find 命令在查找文件时非常有用而且方便。它可以根据不同的条件来查找文件，例如权限、拥有者、修改日期/时间、文件大小等等。在这篇文章中，我们将学习如何使用 find命令以及它所提供的选项来查找文件。在绝大多数Linux系统或MAC OS X系统发行版中，你都可以直接使用 find 命令而无需进行任何安装操作。如果你想让工作在命令行中变得特别高效，那么 find 是你必须掌握的命令之一。 find 命令的基本语法如下：1find [path] [option] [expression] 一 基本用法 列出当前目录和子目录下的所有文件12find .find . -print 这两条命令的效果是一样的，都会列出当前目录和子目录下的所有文件。 查找指定的目录或路径 下面的命令会查找当前目录 Demo 文件夹中的文件，默认列出所有文件。1find ./Demo 下面的命令用于查找当前目录 Demo 文件夹中指定名称的文件。1find ./Demo -name &quot;entry.js&quot; 也可以使用通配符，下面的命令用于查找当前目录 Demo 文件夹中后缀为js的所有文件。1find ./Demo -name &quot;*.js&quot; 忽略大小写 在查找文件名时，忽略大小写往往非常有用。要忽略大小写，只需要把选项name替换成 iname 即可。1find ./Demo -name &quot;*.Js&quot; 限制目录查找的深度 find命令默认会递归查找整个目录树，而这非常消耗时间和资源，好在 find 给我提供了 maxdepth 选项来指定查找的目录深度。1find ./Demo -maxdepth 2 -name &quot;*.css&quot; 反向查找 除了查找满足条件的文件之外，我们还可以查找不满足条件的所有文件。例如当我们知道要在查找中排除哪些文件时，这个选项就非常有用了。12find ./Demo -not -name &quot;*.json&quot;find ./Demo ！ -name &quot;*.json&quot; 这两条命令的效果是一样的，都会列出当前目录和子目录下后缀不为 json 的所有文件。 组合条件查询 我们可以同时使用多个查找条件来指定文件名并排除某些文件。1find ./Demo -name &quot;package*&quot;！ -name &quot;*.json&quot; 上面的命令查找当前目录 Demo 文件夹中所有以 package 开头并且不含 .json 扩展名的文件。 当我们使用多个查找条件时， find 命令会将它们通过 AND 操作符结合起来，也就是说，只有满足所有条件的文件才会被列出。不过，如果我们需要进行基于 OR 运算的查找时，可以加上 -o 开关。1find ./Demo -name &quot;*.json&quot; -o -name ‘*.yaml’ 上面的命令查找当前目录 Demo 文件夹中所有以 .json 结尾或者以 .yaml 结尾的文件。 只查找文件或目录 只查找文件1find ./Demo -type f -name &quot;package*&quot; 只查找目录1find ./Demo -type d -name &quot;css&quot; 同时在多个目录下查找 1find ./Demo ./www -name &quot;package*&quot; 查找隐藏文件 在Linux系统或类Unix系统中，隐藏文件的名字以英文的句号开头，即 . ，所以要列出隐藏文件，只需加上简单的文件名过滤条件就行了。1find ./Demo -type f -name “.*” 二 进阶用法1 基于文件权限和属性的查找通过指定 perm 选项，我们可以查找具有特定权限的文件。下面的示例中查找了所有具有 0664 权限的文件。1find ./Demo -type f -perm 0664 2 基于文件拥有者和用户组的查找通过指定 user 选项，我们可以查找属于特定用户的文件。1find . -user renpingjun -name &quot;package*&quot; 通过指定 group 选项，我们可以查找属于特定用户组的文件。1find . -group developer -name &quot;package*&quot; 3 基于日期与时间的查找查找过去的第 N 天被修改过的文件。1find / -mtime 10 查找过去的 N 天内被访问过的文件。1find / -atime 10 查找过去的 1 小时内被修改过内容的文件。1find / -mmin -60 查找过去的 1 小时内被访问过的文件。1find / -amin -60 4 基于文件大小的查找查找指定大小的文件。1find / -size 50M 查找大小在一定范围内的文件。1find / -size +50M -size -100M 查找空文件和空目录。12find /tmp -type f -emptyfind /tmp -type d -empty 5 其他 使用 ls 命令列出文件信息我们使用 find 命令找到文件后，只能看到文件路径。如果想进一步查看文件信息，可以结合 ls命令来实现。 1find . -exec ls -ld &#123;&#125; 删除找到的文件 下面的命令会删除 tmp 目录下扩展名为 .txt 的文件。1find /tmp -type f -name “*.txt” -exec rm -f &#123;&#125; 我们同样可以删除目录，只要把 -type 后面的 f 改为 d ，并且在 rm 命令后面加上 -r 即可。1find /tmp -type d -name “dirToRemove” -exec rm -r -f &#123;&#125; 当然， find 命令的用法远远不止文中提到的这些，本文只是列举了实际工作中可能用到的一些便捷命令，更多内容请移步到Linux命令教程全面学习。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.renpingjun.top/tags/Linux/"}]},{"title":"Linux命令学习：文件与目录操作","date":"2016-10-17T12:03:00.000Z","path":"2016/10/17/l3sw4heu1/","text":"当在使用Linux的时候，如果您通过 ll (相当于 ls –l )命令就会发现，在/下包涵很多的目录，比如etc、usr、var、bin …等。所以在对文件与目录进行操作之前，我觉得有必要对Linux系统的目录作一下简单的了解。 为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构。最基础的三个目录如下： / (root, 根目录) /usr (unix software resource)：所有系统默认软件都会安装到这个目录； /var (variable)：存放系统或程序运行过程中的数据文件。 一 文件与目录的基本操作1 创建目录与删除目录123mkdir [-mp] 目录名称-m ：配置目录权限-p ：递归创建目录 12rmdir [-p] 目录名称-p ：递归删除目录 2 切换当前目录12345cd [相对路径或绝对路径]cd ..是回到上一级目录cd . 是当前目录cd / 是回到根目录cd ~ 回到用户主目录 3 ls:列出文件或者目录的信息1234ls file|dir-a ：列出全部的文件-d ：仅列出目录本身-l ：以长数据串行列出，包含文件的属性与权限等等数据 4 touch:更新文件时间或者建立新文件123456touch [-acdmt] filename-a ： 更新 atime-c ： 更新 ctime，若该文件不存在则不建立新文件-m ： 更新 mtime-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date=&quot;日期或时间&quot;-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm] 5 cp:复制文件12345678cp source destination-a ：相当于 -dr --preserve=all 的意思，至于 dr 请参考下列说明-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身-i ：若目标文件已经存在时，在覆盖前会先询问-p ：连同文件的属性一起复制过去-r ：递归持续复制-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了 6 rm:删除文件12rm [-fir] 文件或目录-r ：递归删除 7 mv:移动文件12mv [options] source1 source2 source3 .... directory-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖 二 权限与权限修改在Linux系统，权限通常会用一串数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。 文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。 权限修改需要在管理员模式下才能完成，命令为chmod,例如将 .DS_Store 文件的权限修改为 -rwxr-xr– 1sudo chmod 754 .DS_Store 三 链接1 实体链接实体链接和普通文件类似，实体链接文件的 inode 都指向源文件所在的 block 上，也就是说读取文件直接从源文件的 block 上读取。(注意：不能跨越 File System、不能对目录进行链接) 2 符号链接符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，相当于 Windows系统下的快捷方式。当源文件被删除后，链接文件就打不开了。 四 获取文件内容1 cat &amp;&amp; tac1234cat filename 获取文件内容-n ：打印出行号tac filename 是 cat 的反向操作，从最后一行开始打印 2 head &amp;&amp; tail1234head [-n] filename 取得文件前几行-n ：后面接数字，代表显示几行的意思tail filename 是 head 的反向操作，只是取得是后几行 五 指令与文件搜索1 which:指令搜索12which-a ：将所有指令列出 2 whereis:文件搜索1whereis dirname/filename 3 locate:文件搜索locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。 12locate [-ir] keyword-r：正则表达式 4 find:文件搜索这部分内容较多，在另一篇《Linux命令学习：find用法示例》有更详尽的介绍。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.renpingjun.top/tags/Linux/"}]}]