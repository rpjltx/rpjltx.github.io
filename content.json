[{"title":"Linux命令学习：数学运算","date":"2018-05-15T12:03:00.000Z","path":"2018/05/15/heuaa1q2/","text":"在Linux系统中，有很多不同的命令行工具可以完成数字运算，比如说expr、factor、jot 和 bc 命令。 一 expr首先，对于在命令行使用命令进行数学运算，可能最容易想到、最常用的命令就是 expr （表达式expression。它可以完成四则运算，也可以用于比较大小。下面是几个例子： 变量递增1234$ count=0$ count=`expr $count + 1`$ echo $count1 完成简单运算123456789101112$ expr 11 + 123134$ expr 134 / 1112$ expr 134 - 11123$ expr 11 * 123expr: syntax error &lt;== oops!$ expr 11 \\* 1231353$ expr 20 % 32 注意，你需要在 * 运算符之前增加 \\ 符号，避免语法错误。% 运算符用于取余运算。 下面是一个稍微复杂的例子：12345678participants=11total=156share=`expr $total / $participants`remaining=`expr $total - $participants \\* $share`echo $share14echo $remaining2 假设某个活动中有 11 位参与者，需要颁发的奖项总数为 156，那么平均每个参与者获得 14 项奖项，额外剩余 2 个奖项。 比较下面让我们看一下比较的操作。从第一印象来看，语句看似有些怪异；这里并不是设置数值，而是进行数字比较。在本例中 expr 判断表达式是否为真：如果结果是 1，那么表达式为真；反之，表达式为假。 1234$ expr 11 = 111$ expr 11 = 120 请读作“11 是否等于 11？”及“11 是否等于 12？”，你很快就会习惯这种写法。当然，我们不会在命令行上执行上述比较，可能的比较是 $age 是否等于 11。 123$ age=11$ expr $age = 111 如果将数字放到引号中间，那么你将进行字符串比较，而不是数值比较。 1234$ expr &quot;11&quot; = &quot;11&quot;1$ expr &quot;eleven&quot; = &quot;11&quot;0 在本例中，我们判断 10 是否大于 5，以及是否大于 99。1234$ expr 10 \\&gt; 51$ expr 10 \\&gt; 990 的确，返回 1 和 0 分别代表比较的结果为真和假，我们一般预期在 Linux 上得到这个结果。在下面的例子中，按照上述逻辑使用 expr 并不正确，因为 if 的工作原理刚好相反，即 0 代表真。123456789101112#!/bin/bashecho -n &quot;Cost to us&gt; &quot;read costecho -n &quot;Price we&apos;re asking&gt; &quot;read priceif [ `expr $price \\&gt; $cost` ]; then echo &quot;We make money&quot;else echo &quot;Don&apos;t sell it&quot;fi 下面，我们运行这个脚本：1234$ ./checkPriceCost to us&gt; 11.50Price we&apos;re asking&gt; 6We make money 这显然与我们预期不符！我们稍微修改一下，以便使其按我们预期工作：123456789101112#!/bin/bashecho -n &quot;Cost to us&gt; &quot;read costecho -n &quot;Price we&apos;re asking&gt; &quot;read priceif [ `expr $price \\&gt; $cost` == 1 ]; then echo &quot;We make money&quot;else echo &quot;Don&apos;t sell it&quot;fi 二 factorfactor命令用来计算输入数字的因子。例如： 12345678$ factor 111111: 3 37$ factor 134134: 2 67$ factor 1789417894: 2 23 389$ factor 19871987: 1987 三 jotjot 命令可以创建一系列数字。给定数字总数及起始数字即可。 123456789$ jot 8 101011121314151617 你也可以用如下方式使用 jot，这里我们要求递减至数字 2。 12345$ jot 4 10 210752 jot 可以帮你构造一系列数字组成的列表，该列表可以用于其它任务。 12345678$ for i in `jot 7 17`; do echo April $i; doneApril 17April 18April 19April 20April 21April 22April 23 四 bcbc 基本上是命令行数学运算最佳工具之一。输入你想执行的运算，使用管道发送至该命令即可： 12$ echo &quot;123.4+5/6-(7.89*1.234)&quot; | bc113.664 可见 bc 并没有忽略精度，而且输入的字符串也相当直截了当。它还可以进行大小比较、处理布尔值、计算平方根、正弦、余弦和正切等。 1234$ echo &quot;sqrt(256)&quot; | bc16$ echo &quot;s(90)&quot; | bc -l.89399666360055789051 事实上，bc 甚至可以计算 pi。你需要指定需要的精度。12345678$ echo &quot;scale=5; 4*a(1)&quot; | bc -l3.14156$ echo &quot;scale=10; 4*a(1)&quot; | bc -l3.1415926532$ echo &quot;scale=20; 4*a(1)&quot; | bc -l3.14159265358979323844$ echo &quot;scale=40; 4*a(1)&quot; | bc -l3.1415926535897932384626433832795028841968 除了通过管道接收数据并返回结果，bc还可以交互式运行，输入你想执行的运算即可。本例中提到的 scale 设置可以指定有效数字的个数。1234567891011$ bcbc 1.06.95Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.This is free software with ABSOLUTELY NO WARRANTY.For details type `warranty&apos;.scale=23/4.752/3.66quit 你还可以使用 bc 完成数字进制转换。obase 用于设置输出的数字进制。 1234567891011$ bcbc 1.06.95Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.This is free software with ABSOLUTELY NO WARRANTY.For details type `warranty&apos;.obase=1616 &lt;=== entered10 &lt;=== response256 &lt;=== entered100 &lt;=== responsequit 按如下方式使用 bc 也是完成十六进制与十进制转换的最简单方式之一： 1234$ echo &quot;ibase=16; F2&quot; | bc242$ echo &quot;obase=16; 242&quot; | bcF2 在上面第一个例子中，我们将输入进制（ibase）设置为十六进制（hex），完成十六进制到为十进制的转换。在第二个例子中，我们执行相反的操作，即将输出进制（obase）设置为十六进制。 五 简单的 bash 数学运算通过使用双括号，我们可以在 bash 中完成简单的数学运算。在下面的例子中，我们创建一个变量，为变量赋值，然后依次执行加法、自减和平方。 123456789101112$ ((e=11))$ (( e = e + 7 ))$ echo $e18$ ((e--))$ echo $e17$ ((e=e**2))$ echo $e289 允许使用的运算符包括： + - 加法及减法 ++ -- 自增与自减 * / % 乘法、除法及求余数 ^ 指数运算 你还可以使用逻辑运算符和布尔运算符： 1234567891011$ ((x=11)); ((y=7))$ if (( x &gt; y )); then&gt; echo &quot;x &gt; y&quot;&gt; fix &gt; y$ ((x=11)); ((y=7)); ((z=3))$ if (( x &gt; y )) &gt;&gt; (( y &gt; z )); then&gt; echo &quot;letters roll downhill&quot;&gt; filetters roll downhill 或者如下方式： 12$ if [ x &gt; y ] &lt;&lt; [ y &gt; z ]; then echo &quot;letters roll downhill&quot;; filetters roll downhill 下面计算 2 的 3 次幂： 1234$ echo &quot;2 ^ 3&quot;2 ^ 3$ echo &quot;2 ^ 3&quot; | bc8 以上，便是Linux系统下命令行对于数学计算的常用方法。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://renpingjun.cn/tags/Linux/"}]},{"title":"仁平君批评《白先勇细说红楼梦》:缘起","date":"2018-05-15T02:09:46.000Z","path":"2018/05/15/hlm001/","text":"曹雪芹的《红楼梦》是我后来才爱上的一部书。高中课本里节选了林黛玉进贾府一段，但当时觉得文章和其他课文一样，也没有什么特别之处。况且遣词用语生僻、人物关系繁杂、情节多为家庭琐事，实在是提不起来兴趣，读了一两回便无疾而终了。 上了大学之后，大概是课业少时间多的缘故，加上后来古文的基础确实提升了不少，一个偶然的机会在图书馆翻阅到《红楼梦》，读了几回，竟然也觉得不是很难阅读，甚至觉得“妙啊，真是一部好书”。细细体会，小说以神话故事作为切入点，逐步进入现实，再将真事隐去，贾雨村言，这种神话架构非常具有象征意义，很是有趣。再有叙述语句多对仗工整，或排比、或押韵，读来朗朗上口，意境深远引人沉思。再后来，便一发不可收拾的爱上了这部书。本科毕业前读了不下十遍有余，不仅仅是书中所涉及到的诗词曲赋皆能背诵，甚至有些白话情节片段，也能随口背上那么一段。上个周末，我约了几个朋友去逛西郊植物园，途径曹雪芹故居（纪念馆），于是勾起了我重读红楼梦的兴趣。回来后就想着买一套评论研究型著作看看，恰看到白先勇新近出版的《白先勇细说红楼梦》，因此购之阅之，且看他如何细说。 批评？ 文学上的事能说批评吗？当然这里的批评不是日常生活中用语“批评”的那个带有贬义的意思。基于美学意义的解释，批评指通过运用理论方法对作品进行梳理，加以批点评注。","tags":[]},{"title":"JavaScript穷理尽微-数据类型与类型判断","date":"2018-03-02T05:03:00.000Z","path":"2018/03/02/ss3654gddh/","text":"变量刚刚","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://renpingjun.cn/tags/JavaScript/"}]},{"title":"JavaScript穷理尽微-导读","date":"2018-03-02T02:03:00.000Z","path":"2018/03/02/ss34738dh/","text":"屈指一数，吾从事web前端开发迄今已有四载矣。心间颇多感慨，竟不知从何说起，可叹逝者如斯夫。 期间，辗转几家公司，行业各有所属：教育、电商、保险等等不一而足，然立足开发，确是编程语言始相类矣，岂独前端之JavaScript哉。 JavaScript自诞生以来便备受瞩目，不断发展，尤近两年，核心版本已至其六，其语言本身、应用场景、框架模式皆已今非昔比，非当日JavaScript可比肩矣。 吾亦从当年切图仔趋至开发工程师之流，实乃顺时势为之，不见有语言理论体系化之作，心甚愧之。况闻近日项目无新添之事仅维护耳，趁此忙中闲暇，欲重新系统学习JavaScript，名之曰JavaScript穷理尽微。 这是JavaScript穷理尽微系列的第一篇，是为导读。 二零一八年三月二日 于北京泰康三楼 ** 穷理尽微一词出自《文选·答魏太子笺》：“发言抗论，穷理尽微”，意思是系统深入地研究事物的原理，以达到精深奥妙的境地。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://renpingjun.cn/tags/JavaScript/"}]},{"title":"潜心修炼Angular-导读","date":"2018-03-01T02:09:46.000Z","path":"2018/03/01/z3ff3fsdw3s/","text":"这是潜心修炼Angular系列的第一篇，是为导读。","tags":[{"name":"Angular","slug":"Angular","permalink":"http://renpingjun.cn/tags/Angular/"}]},{"title":"http协议面试常见问题","date":"2018-01-20T08:34:40.000Z","path":"2018/01/20/hd4q76ta/","text":"HTTP协议是互联网的基础协议，也是网页开发的必备知识。本文整理了前端面试中涉及到HTTP协议的相关问题。 一 URL详解通常一个完整的URL如下示例： 1schema://host[:port#]/path/.../[?query-string][#anchor] scheme 指定低层使用的协议(例如：http, https, ftp) host HTTP服务器的IP地址或者域名 port# HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 http://www.renpingjun.cn:9091/ path 访问资源的路径 query-string 发送给http服务器的数据 anchor- 锚 二 Get和Post方法的区别 get重点在从服务器上获取资源，post重点在向服务器发送数据； get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用”?”连接，多个请求数据间用”&amp;”连接，这个过程用户是可见的，post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的； 受URL长度限制，get传输的数据量小但效率较高，因为URL是可见的，可能会泄露私密信息；post可以传输大量数据，所以上传文件时只能用post方式，较get安全性较高； get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码,post支持标准字符集，可以正确传递中文字符. 三 常用的HTTP请求方法有哪些？ GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器。 POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。 PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。 HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。 DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。 OPTIONS：查询相应URI支持的HTTP方法。 四 常见状态码及其含义 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求 200：请求被正常处理 204：请求被受理但没有资源可以返回 301：永久性重定向 302：临时重定向 304：发送附带条件的请求时，条件不满足时返回，与重定向无关 400：请求报文语法有误，服务器无法识别 401：请求需要认证 403：请求的对应资源禁止被访问 404：服务器无法找到对应资源 500：服务器内部错误 503：服务器正忙 五 描述http从请求到响应的过程1 域名解析；2 发起tcp的3次握手；3 建立tcp连接后发起http请求；4 服务器端响应http请求，返回给客户端html代码；5 浏览器解析html代码，并请求所需资源；6 浏览器渲染页面呈现给用户。","tags":[{"name":"http","slug":"http","permalink":"http://renpingjun.cn/tags/http/"}]},{"title":"http协议：从看懂浏览器http报文开始","date":"2018-01-18T08:34:40.000Z","path":"2018/01/18/hd4q76ta/","text":"HTTP协议是WWW服务器和用户请求代理（浏览器）之间通过应答请求模式传输超文本内容（html、css、js、图片、接口数据等）的一种协议。 HTTP协议经过了从1.0到2.0的发展，HTTP2相比较与HTTP1有以下几个明显的优点： 采用二进制格式传输数据 使用TCP多路复用的方式来降低网络请求开销 支持传输流的优先级和流量控制机制 支持服务器端推送 通常一个完整的HTTP报文由头部、空行、正文三部分组成。HTTP报文的头部域信息内容有很多，如下图所示： 以谷歌浏览器为例，通过开发者工具可以看到，一个完整的HTTP请求包含General（基本信息）,Request Headers（请求头）,Query String Parameters（请求参数）,Response Headers（响应头）,Response Body（响应体）五部分，每个字段都有自己的逻辑和判断机制，现在我们对一些常见的字段设置作详细解释1234567891011121314151617181920212223242526272829303132333435Request URL:请求路径，通常包含协议、域名、端口号、访问资源路径和请求参数·Request Method:请求方法，比如Get、Post、Put等·Status Code:请求返回的状态码，比如304、200等·Remote Address:请求远端地址·Referrer Policy:主要用作分析用户来源，新的Referrer Policy规定了五种 Referrer 策略：No Referrer、No Referrer When Downgrade、Origin Only、Origin When Cross-origin、和 Unsafe URL-------------------------------User-agent:客户端（浏览器）信息·Cookie:站点cookie信息，可在客户端和服务端之间来回传递·Accept:浏览器接收媒体资源类型，*/*表示所有类型；一般有text/plain,text/html,application/json等等·Accept-Charset:浏览器接收内容字符集，一般是utf-8·Accept-Encoding:浏览器接收内容的编码方法，如指定是否支持压缩、压缩的方法，一般有gzip,deflate,sdch·Accept-language:浏览器接收内容的语言，一般有zh-CN,en等·Allow:设置服务端支持接收哪些HTTP请求方法，如get,post,put等，如果不支持则返回405(Method Not Allowed)·Authorization:授权信息，当客户端接收到来自服务器的WWW-Authenticate响应时，可以用该头部的身份验证信息给web服务器进行认证,比如说Bearer token认证·Cache-Control:服务器缓存控制指令。no-cache表示不使用缓存，要求从服务器请求内容；max-age表示只接受Age值小于max-age的内容，即没有过期的请求对象-----------------------content-length:声明本次回应的数据长度·Expires:web服务器表明该实体在什么时候过期·Server:服务器名称信息，比如Nginx、Openrestry等·Content-Type:web服务器响应的类型，与Accept对应 浏览器发起请求时，会根据头部域字段进行判断是否进行缓存读取，大致流程如下图：","tags":[{"name":"http","slug":"http","permalink":"http://renpingjun.cn/tags/http/"}]},{"title":"JavaScript正则表达式匹配汉字","date":"2017-10-18T12:03:00.000Z","path":"2017/10/18/h473djdgs/","text":"一 正则汉字匹配现状在谷歌搜索「JavaScript 正则表达式匹配汉字」的时候，前几条结果全都是 /[\\u4e00-\\u9fa5]/。没有人怀疑这个正则表达式有什么问题，那么在 2018 年的今天，让我们站在 Chrome 64 的肩膀上，放飞一下自我。 汉文（Han Script）是汉语、日本语、朝鲜语、韩国语的书写系统中的一种文字（Script），越南语在早期也曾在书写系统中使用汉文[1]。汉字（CJK Ideograph）是汉文的基本单元。各国都对汉字提出了自己的编码标准，Unicode 将这些标准加总在一起进行统一编码，力求实现原标准与 Unicode 编码之间的无损转换。Unicode 从语义（semantic）、抽象字形（abstract shape），具体字形（typeface）三个维度[2]出发，把不同编码标准里「起源相同、本义相同、形状一样或稍异」的汉字赋予相同编码，这些被编码的字符称为中日韩统一表意文字（下文我们提到的「汉字」，如果不加说明，均指代中日韩统一表意文字）。如果把它们全部列举出来写成正则表达式，那么就是技术上完整的匹配汉字的正则表达式了。 正则表达式 /[\\u4e00-\\u9fa5]/的意思是匹配所有从 U+4E00, cjk unified ideograph-4e00 到 U+9FA5, cjk unified ideograph-9fa5 的字符。这一段区域对应的是 Unicode 1.0.1 就收录进来的中日韩统一表意文字（CJK Unified Ideographs）区块，在 Unicode 3.0 加入扩展 A 区以前，这个正则表达式确实给出了所有汉字的编码。换言之，从1992年到1999年，这个正则表达式确实是正确的，想必这个表达式已经有20年历史了。 二 匹配所有统一表意文字然而时光飞逝，Unicode 在2017年6月发布了10.0.0版本。在这20年间，Unicode 添加了许多汉字。比如 Unicode 8.0 添加的 109 号化学元素「鿏（⿰⻐麦）」，其码点是 9FCF，不在这个正则表达式范围中。而如果我们期望程序里的 /[\\u4e00-\\u9fa5]/可以与时俱进匹配最新的 Unicode 标准，显然是不现实的事情。因此，我们需要换一个思路，写一个无需维护的正则表达式：1/\\p&#123;Unified_Ideograph&#125;/u 其中 \\u是 ECMAScript 2015 定义的正则表达式标志，意味着将表达式作为 Unicode 码点序列。 \\p是正在提案阶段的正则表达式 Unicode 属性转义，它赋予了我们根据 Unicode 字符的属性数据[3]构造表达式的能力。 Unified_Ideograph是 Unicode 字符的一个二值属性，对于汉字，其取值为 Yes，否则为 No。因此\\p{Unified_Ideograph}匹配所有满足 Unified_Ideograph=yes的 Unicode 字符，而它的底层实现由运行时所依赖的 Unicode 版本决定，开发者不需要知道汉字的具体 Unicode 码点范围。 三 容易混淆的其他 Unicode 属性转义表达式1/\\p&#123;Ideographic&#125;/u 这个表达式匹配所有满足 Ideographic=yes的 Unicode 字符。我们先看一下 UAX #44 对这个属性的解释： Characters considered to be CJKV (Chinese, Japanese, Korean, and Vietnamese) or other siniform (Chinese writing-related) ideographs. This property roughly defines the class of “Chinese characters” and does not include characters of other logographic scripts such as Cuneiform or Egyptian Hieroglyphs. 这个属性表明该字符属于 CJKV 表意文字或者与汉语书写相关的其他表意文字（如西夏文、女书），这个属性粗略地定义了「中文字符」的分类。 四 浏览器兼容性支持截至2018年1月，只有 Chrome 64 支持正则表达式 Unicode 属性转义。对于其他浏览器，我们需要用 babel转译插件@babel/plugin-proposal-unicode-property-regex的底层将带有属性转义的正则表达式转为 Unicode 码点正则表达式或者 ES 5 的正则表达式。转译结果的在线演示可以在这里查看，用户可以自己在上面转译其他的 Unicode 属性转义正则表达式。我们在这里列举 /\\p{Unified_Ideograph}/u转译成Unicode 码点正则表达式的结果： 123const regex = /\\p&#123;Unified_Ideograph&#125;/u;// transpiled to ES6:const regex =/[\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uFA0E\\uFA0F\\uFA11\\uFA13\\uFA14\\uFA1F\\uFA21\\uFA23\\uFA24\\uFA27-\\uFA29\\u&#123;20000&#125;-\\u&#123;2A6D6&#125;\\u&#123;2A700&#125;-\\u&#123;2B734&#125;\\u&#123;2B740&#125;-\\u&#123;2B81D&#125;\\u&#123;2B820&#125;-\\u&#123;2CEA1&#125;\\u&#123;2CEB0&#125;-\\u&#123;2EBE0&#125;]/u; 该插件还可以使用:12345&#123; &quot;plugins&quot;: [ [&quot;@babel/plugin-proposal-unicode-property-regex&quot;, &#123; &quot;useUnicodeFlag&quot;: false &#125;] ]&#125; 配置将表达式转成 ES5 的传统的以字符的 UTF16 表示为序列的字符串，这里不再赘述。 input 元素的 pattern 属性 在前端技术中，除了JavaScript会用到正则表达式，HTML 里元素的pattern属性也会用到正则表达式。与 JavaScript 相比，pattern不支持设置正则表达式的标志位，因此 HTML 标准中强制规定了 input 元素的 pattern 属性需要施加unicode标志 [6]。目前只有 Chrome 53+, Firefox 遵循了这一标准，其他的浏览器暂未支持。 在 React/Angular/Vue.js 三大前端框架中，Angular 提供了近似于 pattern 的指令 ngPattern。目前ngPattern尚未施加unicode标志 [7]。AngularJS 的 ngPattern directive 仍未施加。 在大部分情况，是否施加unicode标志不会对正则表达式产生语义区别。主要的差别在于，在使用\\u{10000}表示 Unicode 码点字符情形，正则表达式/\\u{10000}/代表匹配u一万次，/\\u{10000}/u匹配字符\\u{10000}一次；/./只匹配 BMP 平面的字符，/./u匹配所有平面的字符。 由于 Unicode 属性转义正则表达式依赖于标识位\\u，因此下面的用法目前只能在 Chrome 下使用： 1&lt;input type=&quot;text&quot; pattern=&quot;\\p&#123;Unified_Ideograph&#125;&quot;&gt; 因此，如果需要兼容其他浏览器，可以使用转译插件的底层库regexpu-core在 js 层转换正则表达式，再把转换结果输送到 HTML 模版中。 123456const rewritePattern = require(&quot;regexpu-core&quot;);rewritePattern(&apos;\\\\p&#123;Unified_Ideograph&#125;&apos;, &apos;u&apos;, &#123; &apos;unicodePropertyEscape&apos;: true, &apos;useUnicodeFlag&apos;: false&#125;);// → &apos;/(?:[\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uFA0E\\uFA0F\\uFA11\\uFA13\\uFA14\\uFA1F\\uFA21\\uFA23\\uFA24\\uFA27-\\uFA29]|[\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0])/&apos; 五 总结 /[\\u4e00-\\u9fa5]/是错的，不要用二十年前的正则表达式了。 /\\p{Unified_Ideograph}/u是正确的，不需要维护，匹配所有汉字。这里\\p是 Unicode 属性转义正则表达式。 /\\p{Ideographic}/u 和 /\\p{Script=Han}/u 匹配了除了汉字以外的其他一些字符，在「汉字匹配正则表达式」这个需求下，是错的。 目前只有 Chrome 支持 Unicode 属性转义正则表达式。对其他环境，使用@babel/plugin-proposal-unicode-property-regex 和 regexpu-core 进行优雅降级。 阅读原文：https://qianduan.group/posts/5a6ede120cf6b624d2239c8b","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://renpingjun.cn/tags/JavaScript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://renpingjun.cn/tags/正则表达式/"}]},{"title":"JavaScript正则表达式匹配身份证号码","date":"2017-10-17T12:03:00.000Z","path":"2017/10/17/1f35839j/","text":"我们先来看一段正则代码:1/(^\\d&#123;15&#125;$)|(^\\d&#123;17&#125;([0-9]|X)$)/ 非常眼熟对不对，这是长时间以来我们匹配身份证号码用的正则表达式，而且在google、百度搜索“身份证 正则”等相关关键字时，无一例外结果都是这个答案。 这段代码验证的情况有两种，一种是15位数字，一种是18位（17位数字+1位数字或“X”），好像没有什么问题，但细究起来其实是不严谨的。比如说“123456789012345”是可以通过这个正则验证的，但它却不是一个身份证号码。 无论是15位还是18位，身份证号码都有一套自己的编码规则，我们只要循着规则，不难写出正确（严谨）的身份证号码正则表达式。 一 从身份证号码编码规则说起1 15位身份证号码编码规则15位身份证号码是新中国第一代身份证号码，格式如：ABCDEFYYYYMMDDX 地址码（ABCDEF）表示登记户口时所在地的行政区划代码（省、市、县），如果行政区划进行了重新划分，同一个地方进行户口登记的可能存在地址码不一致的情况。行政区划代码按GB/T2260的规定执行。 出生日期码（YYYYMMDD）表示该居民的出生年月日，年4位数字，月和日分别用2位数字表示，如19491001，；出生日期码是按GB/T 7408的规定执行的。 顺序码（X）表示同一地址码区域内，同年、同月、同日生的人所编订的顺序号，根据自己身份证的顺序码就可以知道：与我们同年同月同日生的同性至少有多少个，且在我们之前登记户籍的有多少人。身份证顺序码的奇数分配给男性，偶数分配给女性。这就是为什么倒数第二位奇数表示男生，偶数表示女生。 2 18位身份证号码编码规则1999年我国颁发了第二代居民身份证号，公民身份号码为18位，且终身不变。居民身份证格式如：ABCDEFYYYYMMDDXXXR 同15位的差别在于顺序码加到了3位，并且增加了校验码（R），R之前的17位被称为本体码，R是根据本体码，按照校验码算法(ISO 7064:1983,MOD 11-2校)计算出来的。当我们输入身份号码进行实名认证的时候，根据校验码算法可以初步判断你输入身份证号码格式是否正确。 校验码（R）的算法是：将本体码各位数字乘以对应加权因子并求和，除以11得到余数，根据余数通过校验码对照表查得校验码。 加权因子 位置序号 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 加权因子 7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2 校验码表 余数 0 1 2 3 4 5 6 7 8 9 10 校验码 1 0 X 9 8 7 6 5 4 3 2 3 应用举例某公民的身份证号码是34052419800101001X， 1 本体码乘以加权因子： 13*7+4*9+0*10+……0*4+1*2=189 2 计算求和后除以11的余数 1189%11=2 3 在检验码中查询余数对应的检验码 余数2所对应的校验码是X，注意X必须大写 二 正则表达式匹配身份证号码清楚了身份证号码的编码规则，再根据规则写出正则表达式就简单了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889isCardNo: function(value) &#123; //验证身份证号方法 var area = &#123; 11: &quot;北京&quot;, 12: &quot;天津&quot;, 13: &quot;河北&quot;, 14: &quot;山西&quot;, 15: &quot;内蒙古&quot;, 21: &quot;辽宁&quot;, 22: &quot;吉林&quot;, 23: &quot;黑龙江&quot;, 31: &quot;上海&quot;, 32: &quot;江苏&quot;, 33: &quot;浙江&quot;, 34: &quot;安徽&quot;, 35: &quot;福建&quot;, 36: &quot;江西&quot;, 37: &quot;山东&quot;, 41: &quot;河南&quot;, 42: &quot;湖北&quot;, 43: &quot;湖南&quot;, 44: &quot;广东&quot;, 45: &quot;广西&quot;, 46: &quot;海南&quot;, 50: &quot;重庆&quot;, 51: &quot;四川&quot;, 52: &quot;贵州&quot;, 53: &quot;云南&quot;, 54: &quot;西藏&quot;, 61: &quot;陕西&quot;, 62: &quot;甘肃&quot;, 63: &quot;青海&quot;, 64: &quot;宁夏&quot;, 65: &quot;新疆&quot;, 71: &quot;台湾&quot;, 81: &quot;香港&quot;, 82: &quot;澳门&quot;, 91: &quot;国外&quot; &#125; var idcard, Y, JYM; var idcard = value.toString(); var S, M; var idcard_array = new Array(); idcard_array = idcard.split(&quot;&quot;); if(area[parseInt(idcard.substr(0, 2))] == null) return false; switch(idcard.length) &#123; case 15: if((parseInt(idcard.substr(6, 2)) + 1900) % 4 == 0 || ((parseInt(idcard.substr(6, 2)) + 1900) % 100 == 0 &amp;&amp; (parseInt(idcard.substr(6, 2)) + 1900) % 4 == 0)) &#123; ereg = /^[1-9][0-9]&#123;5&#125;[0-9]&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))[0-9]&#123;3&#125;$/; //测试出生日期的合法性 &#125; else &#123; ereg = /^[1-9][0-9]&#123;5&#125;[0-9]&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|1[0-9]|2[0-8]))[0-9]&#123;3&#125;$/; //测试出生日期的合法性 &#125; if(ereg.test(idcard)) //return Errors[0]; var res = true; else //return Errors[2]; var res = false; return res; break; case 18: if(parseInt(idcard.substr(6, 4)) % 4 == 0 || (parseInt(idcard.substr(6, 4)) % 100 == 0 &amp;&amp; parseInt(idcard.substr(6, 4)) % 4 == 0)) &#123; ereg = /^[1-9][0-9]&#123;5&#125;[1-2][0-9][0-9]&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))[0-9]&#123;3&#125;[0-9Xx]$/; //闰年出生日期的合法性正则表达式 &#125; else &#123; ereg = /^[1-9][0-9]&#123;5&#125;[1-2][0-9][0-9]&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|1[0-9]|2[0-8]))[0-9]&#123;3&#125;[0-9Xx]$/; //平年出生日期的合法性正则表达式 &#125; if(ereg.test(idcard)) &#123; S = (parseInt(idcard_array[0]) + parseInt(idcard_array[10])) * 7 + (parseInt(idcard_array[1]) + parseInt(idcard_array[11])) * 9 + (parseInt(idcard_array[2]) + parseInt(idcard_array[12])) * 10 + (parseInt(idcard_array[3]) + parseInt(idcard_array[13])) * 5 + (parseInt(idcard_array[4]) + parseInt(idcard_array[14])) * 8 + (parseInt(idcard_array[5]) + parseInt(idcard_array[15])) * 4 + (parseInt(idcard_array[6]) + parseInt(idcard_array[16])) * 2 + parseInt(idcard_array[7]) * 1 + parseInt(idcard_array[8]) * 6 + parseInt(idcard_array[9]) * 3; Y = S % 11; M = &quot;F&quot;; JYM = &quot;10X98765432&quot;; M = JYM.substr(Y, 1); if(M == idcard_array[17]) //return Errors[0]; var res = true; else //return Errors[3]; var res = false; &#125; else //return Errors[2]; res = false; return res; break; default: res = false; return res; break; &#125;;&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://renpingjun.cn/tags/JavaScript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://renpingjun.cn/tags/正则表达式/"}]},{"title":"MYSQL 基本操作指南","date":"2017-04-29T08:59:00.000Z","path":"2017/04/29/c19517s2/","text":"环境：Linux Ubuntu14.04, MYSQL5.5 1.登录数据库服务器1234567mysql -u root -p (默认端口3306)·mysql -u root -p --protocol=tcp --host=localhost --port=3307 （通过tcp连接管理不同端口的MYSQL）·mysql -u root -p --socket=/tmp/mysql3307.sock （通过socket套接字连接管理不同端口的MYSQL）·mysql -u root -p 3306 -h 127.0.0.1 （通过端口和IP管理不同端口的MYSQL） 2.数据库操作123456789SHOW DATABASES; （显示所有数据库）·CREATE DATABASE vue_ghs; （创建一个名为vue_ghs的数据库）·DROP DATABASE vue_ghs; （删除数据库）·USE vue_ghs; （选择将要操作的数据库）·SOURCE vue_ghs.sql; （MYSQL导入.sql文件） 3.表操作12345678910111213141516171819202122SHOW TABLES; （显示所有数据表）·CREATE TABLE `renpingjun` ( `id` INT( 5 ) UNSIGNED NOT NULL AUTO_INCREMENT , `username` VARCHAR( 20 ) NOT NULL , `password` CHAR( 32 ) NOT NULL , `time` DATETIME NOT NULL , `number` FLOAT( 10 ) NOT NULL , `content` TEXT NOT NULL , PRIMARY KEY ( `id` ) ) ENGINE = MYISAM ; （创建数据表renpingjun：在mysql&gt;后粘贴以下SQL语句，存储引擎为MYISAM，字段id为主键、唯一索引）·DESCRIBE renpingjun; （查看renpingjun数据表结构）·SELECT * FROM renpingjun; （从renpingjun数据表中检索所有记录）·SELECT * FROM renpingjun WHERE username = abc AND number=1 ORDER BY id DESC; （从renpingjun数据表中检索username = abc AND number=1的记录，按字段id降序排序）·INSERT INTO renpingjun (id, username, password, time, number, content) VALUES (, abc, 123456,2017-04-29 14:32:12, 23.41, hello world); （插入信息到renpingjun数据表）·UPDATE renpingjun SET content = hello china WHERE username = abc; （更新数据表信息）·UPDATE renpingjun SET content = REPLACE (content, aaa, bbb); （批量替换renpingjun数据表中content字段中的“aaa”为“bbb”）·DELETE FROM renpingjun; （清空renpingjun数据表）·DROP TABLE renpingjun; （删除renpingjun数据表）·REPAIR TABLE renpingjun; （修复损坏的renpingjun数据表） 4.数据库权限操作1234567GRANT ALL PRIVILEGES ON *.* TO renpingjun@% IDENTIFIED BY 123456; （创建一个具有root权限，可从任何IP登录的用户renpingjun，密码为123456）·GRANT SELECT , INSERT , UPDATE , DELETE , FILE , CREATE , DROP , INDEX , ALTER , CREATETEMPORARY TABLES , CREATE VIEW , SHOW VIEW , CREATE ROUTINE, ALTER ROUTINE, EXECUTE ON*.* TO xiawei@192.168.1.% IDENTIFIED BY 123456; （创建一个具有数据操作、结构操作权限，只能从IP为192.168.1登录的用户xiawei,密码为123456）·DROP USER xiawei@%; （删除用户xiawei） 5.登出数据库服务器1exit;","tags":[{"name":"mysql","slug":"mysql","permalink":"http://renpingjun.cn/tags/mysql/"}]},{"title":"Git面试问题详解","date":"2016-11-15T11:48:00.000Z","path":"2016/11/15/g1953e22/","text":"1 Gitflow工作流程git关键分支：master 主分支；develop 主开发分支，包含确定即将发布的代码；feature 新功能分支，一般一个新功能对应一个分支，对于功能的拆分需要比较合理，以避免一些后面不必要的代码冲突；release 发布分支，发布时候用的分支，一般测试时候发现的 bug 在这个分支进行修复；hotfix hotfix 分支，紧急修 bug 的时候用。 分支关系：feature 分支都是从 develop 分支创建，完成后再合并到 develop 分支上，等待发布；当需要发布时，我们从 develop 分支创建一个 release 分支，然后这个 release 分支会发布到测试环境进行测试，如果发现问题就在这个分支直接进行修复。在所有问题修复之前，我们会不停的重复发布-&gt;测试-&gt;修复-&gt;重新发布-&gt;重新测试这个流程。发布结束后，这个 release 分支会合并到 develop 和 master 分支，从而保证不会有代码丢失；master 分支只跟踪已经发布的代码，合并到 master 上的 commit 只能来自 release 分支和 hotfix 分支；hotfix 分支的作用是紧急修复一些 Bug，它们都是从 master 分支上的某个 tag 建立，修复结束后再合并到 develop 和 master 分支上； 2 GitFlow 的优势： 并行开发：GitFlow 可以很方便的实现并行开发：每个新功能都会建立一个新的 feature 分支，从而和已经完成的功能隔离开来，而且只有在新功能完成开发的情况下，其对应的 feature 分支才会合并到主开发分支上（也就是我们经常说的 develop 分支）。另外，如果你正在开发某个功能，同时又有一个新的功能需要开发，你只需要提交当前 feature 的代码，然后创建另外一个 feature 分支并完成新功能开发。然后再切回之前的 feature 分支即可继续完成之前功能的开发。 协作开发：GitFlow 还支持多人协同开发，因为每个 feature 分支上改动的代码都只是为了让某个新的 feature 可以独立运行。同时我们也很容易知道每个人都在做什么。 发布阶段：当一个新 feature 开发完成的时候，它会被合并到 develop 分支，这个分支主要用来暂时保存那些还没有发布的内容，所以如果需要再开发新的 feature，我们只需要从 develop 分支创建新分支，即可包含所有已经完成的 feature 。 支持紧急修复：GitFlow 还包含了 hotfix 分支。这种类型的分支是从某个已经发布的 tag 上创建出来并做一个紧急的修复，而且这个紧急修复只影响这个已经发布的 tag，而不会影响到你正在开发的新 feature。 3 Git仓库组成部分及其相互之间的转换关系 git仓库由三个部分组成：工作区（Working Directory）、暂存区（Stage）和历史记录区（History）。 工作区：在 git 管理下的正常目录都算是工作区，我们平时的编辑工作都是在工作区完成。 暂存区：也就是临时区域，里面存放将要提交文件的快照。 历史记录区：git commit 后的记录区。 三个区的转换关系以及转换所使用的命令： 4 git reset、git revert 和 git checkout 有什么区别git reset 可以将一个分支的末端指向之前的一个 commit。然后再下次 git 执行垃圾回收的时候，会把这个 commit 之后的 commit 都扔掉。git reset 还支持三种标记，用来标记 reset 指令影响的范围：（1）–mixed：会影响到暂存区和历史记录区。也是默认选项；（2）–soft：只影响历史记录区；（3）–hard：影响工作区、暂存区和历史记录区。 git checkout 可以将 HEAD 移到一个新的分支，并更新工作目录。因为可能会覆盖本地的修改，所以执行这个指令之前，你需要 stash 或者 commit 暂存区和工作区的更改。 git revert 和 git reset 的目的是一样的，但是做法不同，它会以创建新的 commit 的方式来撤销 commit，这样能保留之前的 commit 历史，比较安全。另外，同样因为可能会覆盖本地的修改，所以执行这个指令之前，你需要 stash 或者 commit 暂存区和工作区的更改。","tags":[{"name":"Git","slug":"Git","permalink":"http://renpingjun.cn/tags/Git/"}]},{"title":"Git工作流程","date":"2016-11-14T12:34:00.000Z","path":"2016/11/14/g19527sq/","text":"引子Git作为一个分布式版本控制系统，通常会涉及到多人协作。而协作必须有一个规范的工作流程，让大家有效地合作，使得项目井井有条地发展下去。”工作流程”在英语里，叫做”workflow”或者”flow”，意思就是项目像水流那样，顺畅、自然地向前流动，不会发生冲击、对撞、甚至漩涡。本文介绍三种广泛使用的工作流程： Git flow Github flow Gitlab flow 一 Git flowGit flow是最早诞生、并得到广泛采用的一种工作流程，详细介绍参考：A successful Git branching model 在Git flow 流中，项目存在两个长期分支，即主分支master和开发分支develop，前者用于存放对外发布的版本，任何时候在这个分支拿到的，都是稳定的分布版；后者用于日常开发，存放最新的开发版。同时项目存在三种短期分支（非必需），即功能分支（feature branch）、补丁分支（hotfix branch）、预发分支（release branch）。 二 Github flowGithub flow 是 Github.com 使用的工作流程，是Git flow的简化版，专门配合”持续发布”。它只有一个长期分支，就是master，因此用起来非常简单。官方推荐流程如下，详情参见：Understanding the GitHub Flow 1：根据需求，从master拉出新分支，不区分功能分支或补丁分支。 2：新分支开发完成后，或者需要讨论的时候，就向master发起一个pull request（简称PR）。 3：Pull Request既是一个通知，让别人注意到你的请求，又是一种对话机制，大家一起评审和讨论你的代码。对话过程中，你还可以不断提交代码。 4：你的Pull Request被接受，合并进master，重新部署后，原来你拉出来的那个分支就被删除。（先部署再合并也可。） 三 Gitlab flowGitlab flow 吸取了Git flow 与 Github flow的优点，既有适应不同开发环境的弹性，又有单一主分支的简单和便利。它是 Gitlab.com 推荐的做法。Gitlab flow 的最大原则叫做”上游优先”（upstream first），即只存在一个主分支master，它是所有其他分支的”上游”。只有上游分支采纳的代码变化，才能应用到其他分支。 对于”持续发布”的项目，它建议在master分支以外，再建立不同的环境分支。比如，”开发环境”的分支是master，”预发环境”的分支是pre-production，”生产环境”的分支是production。开发分支是预发分支的”上游”，预发分支又是生产分支的”上游”。代码的变化，必须由”上游”向”下游”发展。比如，生产环境出现了bug，这时就要新建一个功能分支，先把它合并到master，确认没有问题，再cherry-pick到pre-production，这一步也没有问题，才进入production。只有紧急情况，才允许跳过上游，直接合并到下游分支。 对于”版本发布”的项目，建议的做法是每一个稳定版本，都要从master分支拉出一个分支，比如2-3-stable、2-4-stable等等。以后，只有修补bug，才允许将代码合并到这些分支，并且此时要更新小版本号。 四 其他1 Pull Request功能分支合并进master分支，必须通过Pull Request（Gitlab里面叫做 Merge Request）； 2 Protected branchmaster分支应该受到保护，不是每个人都可以修改这个分支，以及拥有审批 Pull Request 的权力。Github 和 Gitlab 都提供”保护分支”（Protected branch）这个功能。 3 IssueIssue 用于 Bug追踪和需求管理。建议先新建 Issue，再新建对应的功能分支。功能分支总是为了解决一个或多个 Issue。功能分支的名称，可以与issue的名字保持一致，并且以issue的编号起首，比如”15-require-a-password-to-change-it”。 4 Merge节点Git有两种合并：一种是”直进式合并”（fast forward），不生成单独的合并节点；另一种是”非直进式合并”（none fast-forward），会生成单独节点。前者不利于保持commit信息的清晰，也不利于以后的回滚，建议总是采用后者（即使用–no-ff参数）。只要发生合并，就要有一个单独的合并节点。 5 Squash 多个commit为了便于他人阅读你的提交，也便于cherry-pick或撤销代码变化，在发起Pull Request之前，应该把多个commit合并成一个。（前提是，该分支只有你一个人开发，且没有跟master合并过。）这可以采用rebase命令附带的squash操作。","tags":[{"name":"Git","slug":"Git","permalink":"http://renpingjun.cn/tags/Git/"}]},{"title":"Git基本使用指南","date":"2016-11-13T11:48:00.000Z","path":"2016/11/13/g19527s2/","text":"引子在团队项目开发里，经常会遇到一个项目由多人通力合作完成的情况，每个人负责其中一个模块，开发过程中为了确保代码追本溯源，我们引入了版本控制概念，每个人修改了什么代码或提交了什么代码都能够跟踪记录。现在流行的版本控制主要有：集中式版本控制（Svn）和分布式版本控制（Git）。Git由于其分布式开发，速度快、使用灵活，为大多数开发者所青睐。本文将介绍Git的基本使用方法。 一 初始化Git仓库Git仓库分为两种类型：一种是存放在服务器上面的空仓库（也称裸仓库），里面没有保存文件，只是存放.git的内容；一种是标准仓库，会在项目根目录下创建一个.git目录。 1234$ git init &lt;project_name&gt; # 创建标准仓库，在项目根目录下创建一个隐藏的.git# 文件夹$ git init --bare &lt;project_name&gt; # 创建一个裸仓库，裸仓库只有.git目录内容，# 而没有工作区域，一般用于在共享服务器上面创建。 二 查看当前Git配置Git配置信息分成三个级别，分别存放在三个不同的地方： 一个是系统级别的配置文件，系统基本配置文件存放在Git的安装目录中； 一个是用户级别配置文件，用户级别配置文件存放在当前用户目录下的.gitconfig文件内； 一个是项目级别配置文件，项目级别的配置文件会存放在.git目录的config文件中。使用git config –list显示的Git配置信息，是从系统级配置•用户级配置•项目级配置一层层叠加显示出来的，当遇到同项不同内容时以低级的配置为准。 1234567$ git config --list # 显示当前Git配置信息$ git config --system --list # 显示系统级别Git配置信息$ cat .git/config # 显示项目配置文件$ cat ~/.gitconfig # 显示用户级别配置信息 三 配置当前用户名和邮箱用Git进行版本控制与集中式版本控制不同，集中版本控制需要验证用户信息后才能提交代码，这样可以识别出谁提交了代码；而分布式版本控制的所有文件都保存在本地磁盘中，当提交代码的时候，需要配置一个用户信息才能被Git执行，在团体合作开发的时候用于识别文件是谁提交的。 12$ git config --global user.name &quot;用户名&quot; # 在用户级配置上设置用户名$ git config --global user.email &quot;用户邮箱&quot; # 在用户级配置上设置邮箱 四 克隆仓库克隆仓库是从远程服务器上拉取一个完整的仓库到本地磁盘，这样做的好处在于每个人都有一个完整的代码库，避免把鸡蛋放在同一个篮子里。但相对的，每个人都有一个完整仓库，对代码的防泄露又是一个问题。Git支持URL传输协议：本地协议（Local）、HTTP 协议、SSH（Secure Shell）协议、FTP协议、Git 协议。 1$ git clone &lt;url&gt; # 从一个远程Git仓库中克隆到本地磁盘 五 查看文件状态使用git status可以查看当前工作区域内文件的状态，没被跟踪内容会在Untracked files中显示，可以通过git add 添加被跟踪。1$ git status 六 添加文件追踪使用git add 命令将文件添加到index（索引）文件中，这些文件列表将在下一次提交时记录到仓库。1$ git add renpingjun/ # 将renpingjun目录添加到index文件中 七 提交代码使用git commit命令将index文件中的更改记录提交到本地版本库。使用参数-m可以直接将要添加的备注信息写入。1$ git commit -m &quot;add app folder&quot; # 提交到版本库，并写入提交信息 八 查看远程仓库使用git remote命令可以显示当前版本库的远程仓库服务器信息。参数-v显示远程仓库简写名称和URL地址。1$ git remote -v # 显示版本库连接的远程仓库和URL 九 添加远程仓库使用git remote add &lt;远程仓库别名&gt; 为本地版本库添加一个远程仓库。1$ git remote add origin https://github.com/rpjltx/node-practice.git # 添加一个远程仓库 十 推送代码使用git push &lt;远程仓库别名&gt; &lt;本地分支&gt;将本地版本库推送到远程仓库。1$ git push origin master # 将本地master分支提交到别名为origin的远程仓库 十一 从远程仓库更新代码到本地将代码推送到远程仓库后，其他非最新版本的用户需要更新最新代码，可以使用git fetch或git pull命令来更新。区别在于fetch获取最新的代码到本地仓库，但不会自动合并分支，需要比较分支差异后合并，而pull则直接将远程仓库的版本合并到本地master上，所以git fetch相对安全些。12$ git fetch origin master # 下载origin最新的代码$ git merge origin/master # 将origin/master分支合并到本地master中 十二 版本标记有些老师会把版本标记翻译成里程碑，即给当前提交定义一个标签，标记出当前提交内容有别于其他提交。例如，在开发完一个新功能后，可以将其标记一个v1.1，代表这个功能开发完成，方便以后历史中定位这次提交。 Git有两种标签类型：一种是lightweight轻量级标签，只有版本号无其他信息；另一种是annotated附注标签，标签附带一条信息，可以让别人快速识别标签作用，建议使用这种标签。 使用git tag -n[数字] 显示当前分支下的标签信息，参数-n代表显示备注信息行数。使用git tag -a &lt;版本号&gt; -m“备注”为最新提交打上标签。使用git show &lt;版本号&gt;显示对应标签的版本信息和提交差异。 十三 添加忽略文件在当前项目根目录下创建一个.gitignore文件，用于保存忽略列表。配置语法如下： “/”代表目录； “*”代表通配任意字符； “？”代表通配单个字符； “[]”代表单个字符的匹配列表； “！”表示不忽略，一定要跟踪。 十四 查看当前处在的分支使用命令 git branch可以查看当前工作目录所在的分支。 十五 创建分支使用命令git checkout -b rpj创建并切换到rpj分支，命令git checkout -b等同于同时执行了命令git branch rpj 创建分支和命令git checkout rpj切换到rpj分支 十六 合并分支使用命令git merge合并两个分支。 十七 解决冲突之前使用了不同的忽略语句，两个分支间没有冲突，但是如果两个分支同时修改了同一个文件相同位置的不同参数时，在合并的时候就会产生冲突。人工修改冲突部分，需要将自动生成的&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD、=======、&gt;&gt;&gt;&gt;&gt;&gt;&gt; jsb全部删除，自行判断冲突部分需要保留什么内容或者将两者融合，修改完成后保存文件，重新使用命令git add添加文件，后再提交一次，即可解决冲突问题。","tags":[{"name":"Git","slug":"Git","permalink":"http://renpingjun.cn/tags/Git/"}]},{"title":"Jquery源码阅读-导读","date":"2016-11-01T02:09:46.000Z","path":"2016/11/01/j12wsa8jy/","text":"这是Jquery源码阅读系列的第一篇，是为导读。","tags":[{"name":"Jquery","slug":"Jquery","permalink":"http://renpingjun.cn/tags/Jquery/"}]},{"title":"Linux命令学习：压缩与打包","date":"2016-10-19T12:03:00.000Z","path":"2016/10/19/l3sw4haqz/","text":"首先明确我们见到的压缩包分成两种：1，打包 即将分散的文件合并为一个文件，这在存储，传输中都是极为有利的。（如某源代码有成千的源文件，在复制、网络传递过程中需要每个文件单独发起。可以复制相同大小的压缩包和零散文件的文件夹对比一下时间）2，压缩 即通过各种算法减小打包文件的总大小，减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。 Linux 底下有很多压缩文件名，常见的如下： 扩展名 压缩程序 *.Z compress *.zip zip *.gz gzip *.bz2 bzip2 *.xz xz *.tar tar 程序打包的数据，没有经过压缩 *.tar.gz tar 程序打包的文件，经过 gzip 的压缩 *.tar.bz2 tar 程序打包的文件，经过 bzip2 的压缩 *.tar.xz tar 程序打包的文件，经过 xz 的压缩 一 tartar命令可以用来压缩打包单文件、多个文件、单个目录、多个目录。常用命令如下： 123456tar czvf my.tar file1 单个文件压缩打包tar czvf my.tar file1 file2,... 多个文件压缩打包tar czvf my.tar dir1 单个目录压缩打包tar czvf my.tar dir1 dir2 多个目录压缩打包tar xzvf my.tar 解包至当前目录 下面是常用参数解释，其他参数请参考文档12345678z ：使用 zip-j ：使用 bzip2-J ：使用 xz-c ：新建打包文件-t ：查看打包文件里面有哪些文件-x ：解打包或解压缩的功能-v ：在压缩/解压缩的过程中，显示正在处理的文件名-f ：使用档名（注意： f 之后要立即接档名，不能接参数，例 tar -zcvPf tfile sfile） 二 gzipgzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件，经过 gzip 压缩过，源文件就不存在了。123456gzip filename-c ：将压缩的数据输出到屏幕上-d ：解压缩-t ：检验压缩文件是否出错-v ：显示压缩比等信息-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6 三 bzip2提供比 gzip 更高的压缩比。 查看命令：bzcat、bzmore、bzless、bzgrep.12bzip2 filename-k ：保留源文件 四 xzxz提供比 bzip2 更佳的压缩比。查看命令：xzcat、xzmore、xzless、xzgrep.1xz filename","tags":[{"name":"Linux","slug":"Linux","permalink":"http://renpingjun.cn/tags/Linux/"}]},{"title":"Linux命令学习：find用法示例","date":"2016-10-18T12:03:00.000Z","path":"2016/10/18/l344heua/","text":"Linux系统中的 find 命令在查找文件时非常有用而且方便。它可以根据不同的条件来查找文件，例如权限、拥有者、修改日期/时间、文件大小等等。在这篇文章中，我们将学习如何使用 find命令以及它所提供的选项来查找文件。在绝大多数Linux系统或MAC OS X系统发行版中，你都可以直接使用 find 命令而无需进行任何安装操作。如果你想让工作在命令行中变得特别高效，那么 find 是你必须掌握的命令之一。 find 命令的基本语法如下：1find [path] [option] [expression] 一 基本用法 列出当前目录和子目录下的所有文件12find .find . -print 这两条命令的效果是一样的，都会列出当前目录和子目录下的所有文件。 查找指定的目录或路径 下面的命令会查找当前目录 Demo 文件夹中的文件，默认列出所有文件。1find ./Demo 下面的命令用于查找当前目录 Demo 文件夹中指定名称的文件。1find ./Demo -name &quot;entry.js&quot; 也可以使用通配符，下面的命令用于查找当前目录 Demo 文件夹中后缀为js的所有文件。1find ./Demo -name &quot;*.js&quot; 忽略大小写 在查找文件名时，忽略大小写往往非常有用。要忽略大小写，只需要把选项name替换成 iname 即可。1find ./Demo -name &quot;*.Js&quot; 限制目录查找的深度 find命令默认会递归查找整个目录树，而这非常消耗时间和资源，好在 find 给我提供了 maxdepth 选项来指定查找的目录深度。1find ./Demo -maxdepth 2 -name &quot;*.css&quot; 反向查找 除了查找满足条件的文件之外，我们还可以查找不满足条件的所有文件。例如当我们知道要在查找中排除哪些文件时，这个选项就非常有用了。12find ./Demo -not -name &quot;*.json&quot;find ./Demo ！ -name &quot;*.json&quot; 这两条命令的效果是一样的，都会列出当前目录和子目录下后缀不为 json 的所有文件。 组合条件查询 我们可以同时使用多个查找条件来指定文件名并排除某些文件。1find ./Demo -name &quot;package*&quot;！ -name &quot;*.json&quot; 上面的命令查找当前目录 Demo 文件夹中所有以 package 开头并且不含 .json 扩展名的文件。 当我们使用多个查找条件时， find 命令会将它们通过 AND 操作符结合起来，也就是说，只有满足所有条件的文件才会被列出。不过，如果我们需要进行基于 OR 运算的查找时，可以加上 -o 开关。1find ./Demo -name &quot;*.json&quot; -o -name ‘*.yaml’ 上面的命令查找当前目录 Demo 文件夹中所有以 .json 结尾或者以 .yaml 结尾的文件。 只查找文件或目录 只查找文件1find ./Demo -type f -name &quot;package*&quot; 只查找目录1find ./Demo -type d -name &quot;css&quot; 同时在多个目录下查找 1find ./Demo ./www -name &quot;package*&quot; 查找隐藏文件 在Linux系统或类Unix系统中，隐藏文件的名字以英文的句号开头，即 . ，所以要列出隐藏文件，只需加上简单的文件名过滤条件就行了。1find ./Demo -type f -name “.*” 二 进阶用法1 基于文件权限和属性的查找通过指定 perm 选项，我们可以查找具有特定权限的文件。下面的示例中查找了所有具有 0664 权限的文件。1find ./Demo -type f -perm 0664 2 基于文件拥有者和用户组的查找通过指定 user 选项，我们可以查找属于特定用户的文件。1find . -user renpingjun -name &quot;package*&quot; 通过指定 group 选项，我们可以查找属于特定用户组的文件。1find . -group developer -name &quot;package*&quot; 3 基于日期与时间的查找查找过去的第 N 天被修改过的文件。1find / -mtime 10 查找过去的 N 天内被访问过的文件。1find / -atime 10 查找过去的 1 小时内被修改过内容的文件。1find / -mmin -60 查找过去的 1 小时内被访问过的文件。1find / -amin -60 4 基于文件大小的查找查找指定大小的文件。1find / -size 50M 查找大小在一定范围内的文件。1find / -size +50M -size -100M 查找空文件和空目录。12find /tmp -type f -emptyfind /tmp -type d -empty 5 其他 使用 ls 命令列出文件信息我们使用 find 命令找到文件后，只能看到文件路径。如果想进一步查看文件信息，可以结合 ls命令来实现。 1find . -exec ls -ld &#123;&#125; 删除找到的文件 下面的命令会删除 tmp 目录下扩展名为 .txt 的文件。1find /tmp -type f -name “*.txt” -exec rm -f &#123;&#125; 我们同样可以删除目录，只要把 -type 后面的 f 改为 d ，并且在 rm 命令后面加上 -r 即可。1find /tmp -type d -name “dirToRemove” -exec rm -r -f &#123;&#125; 当然， find 命令的用法远远不止文中提到的这些，本文只是列举了实际工作中可能用到的一些便捷命令，更多内容请移步到Linux命令教程全面学习。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://renpingjun.cn/tags/Linux/"}]},{"title":"Linux命令学习：文件与目录操作","date":"2016-10-17T12:03:00.000Z","path":"2016/10/17/l3sw4heu1/","text":"当在使用Linux的时候，如果您通过 ll (相当于 ls –l )命令就会发现，在/下包涵很多的目录，比如etc、usr、var、bin …等。所以在对文件与目录进行操作之前，我觉得有必要对Linux系统的目录作一下简单的了解。 为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构。最基础的三个目录如下： / (root, 根目录) /usr (unix software resource)：所有系统默认软件都会安装到这个目录； /var (variable)：存放系统或程序运行过程中的数据文件。 一 文件与目录的基本操作1 创建目录与删除目录123mkdir [-mp] 目录名称-m ：配置目录权限-p ：递归创建目录 12rmdir [-p] 目录名称-p ：递归删除目录 2 切换当前目录12345cd [相对路径或绝对路径]cd ..是回到上一级目录cd . 是当前目录cd / 是回到根目录cd ~ 回到用户主目录 3 ls:列出文件或者目录的信息1234ls file|dir-a ：列出全部的文件-d ：仅列出目录本身-l ：以长数据串行列出，包含文件的属性与权限等等数据 4 touch:更新文件时间或者建立新文件123456touch [-acdmt] filename-a ： 更新 atime-c ： 更新 ctime，若该文件不存在则不建立新文件-m ： 更新 mtime-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date=&quot;日期或时间&quot;-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm] 5 cp:复制文件12345678cp source destination-a ：相当于 -dr --preserve=all 的意思，至于 dr 请参考下列说明-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身-i ：若目标文件已经存在时，在覆盖前会先询问-p ：连同文件的属性一起复制过去-r ：递归持续复制-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了 6 rm:删除文件12rm [-fir] 文件或目录-r ：递归删除 7 mv:移动文件12mv [options] source1 source2 source3 .... directory-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖 二 权限与权限修改在Linux系统，权限通常会用一串数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。 文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。 权限修改需要在管理员模式下才能完成，命令为chmod,例如将 .DS_Store 文件的权限修改为 -rwxr-xr– 1sudo chmod 754 .DS_Store 三 链接1 实体链接实体链接和普通文件类似，实体链接文件的 inode 都指向源文件所在的 block 上，也就是说读取文件直接从源文件的 block 上读取。(注意：不能跨越 File System、不能对目录进行链接) 2 符号链接符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，相当于 Windows系统下的快捷方式。当源文件被删除后，链接文件就打不开了。 四 获取文件内容1 cat &amp;&amp; tac1234cat filename 获取文件内容-n ：打印出行号tac filename 是 cat 的反向操作，从最后一行开始打印 2 head &amp;&amp; tail1234head [-n] filename 取得文件前几行-n ：后面接数字，代表显示几行的意思tail filename 是 head 的反向操作，只是取得是后几行 五 指令与文件搜索1 which:指令搜索12which-a ：将所有指令列出 2 whereis:文件搜索1whereis dirname/filename 3 locate:文件搜索locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。 12locate [-ir] keyword-r：正则表达式 4 find:文件搜索这部分内容较多，在另一篇《Linux命令学习：find用法示例》有更详尽的介绍。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://renpingjun.cn/tags/Linux/"}]}]