[{"title":"MySQL 优化原理[转]","date":"2017-05-01T10:45:00.000Z","path":"2017/05/01/c19527s2/","text":"说起MySQL的查询优化，相信大家收藏了一堆奇淫技巧：不能使用SELECT *、不使用NULL字段、合理创建索引、为字段选择合适的数据类型….. 你是否真的理解这些优化技巧？是否理解其背后的工作原理？在实际场景下性能真有提升吗？我想未必。因而理解这些优化建议背后的原理就尤为重要，希望本文能让你重新审视这些优化建议，并在实际业务场景下合理的运用。 MySQL逻辑架构如果能在头脑中构建一幅MySQL各组件之间如何协同工作的架构图，有助于深入理解MySQL服务器。下图展示了MySQL的逻辑架构图。 MySQL逻辑架构 MySQL逻辑架构整体分为三层，最上层为客户端层，并非MySQL所独有，诸如：连接处理、授权认证、安全等功能均在这一层处理。 MySQL大多数核心服务均在中间这一层，包括查询解析、分析、优化、缓存、内置函数(比如：时间、数学、加密等函数)。所有的跨存储引擎的功能也在这一层实现：存储过程、触发器、视图等。 最下层为存储引擎，其负责MySQL中的数据存储和提取。和Linux下的文件系统类似，每种存储引擎都有其优势和劣势。中间的服务层通过API与存储引擎通信，这些API接口屏蔽了不同存储引擎间的差异。 MySQL查询过程我们总是希望MySQL能够获得更高的查询性能，最好的办法是弄清楚MySQL是如何优化和执行查询的。一旦理解了这一点，就会发现：很多的查询优化工作实际上就是遵循一些原则让MySQL的优化器能够按照预想的合理方式运行而已。 当向MySQL发送一个请求的时候，MySQL到底做了些什么呢？ MySQL查询过程 客户端/服务端通信协议MySQL客户端/服务端通信协议是“半双工”的：在任一时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时发生。一旦一端开始发送消息，另一端要接收完整个消息才能响应它，所以我们无法也无须将一个消息切成小块独立发送，也没有办法进行流量控制。 客户端用一个单独的数据包将查询请求发送给服务器，所以当查询语句很长的时候，需要设置max_allowed_packet参数。但是需要注意的是，如果查询实在是太大，服务端会拒绝接收更多数据并抛出异常。 与之相反的是，服务器响应给用户的数据通常会很多，由多个数据包组成。但是当服务器响应客户端请求时，客户端必须完整的接收整个返回结果，而不能简单的只取前面几条结果，然后让服务器停止发送。因而在实际开发中，尽量保持查询简单且只返回必需的数据，减小通信间数据包的大小和数量是一个非常好的习惯，这也是查询中尽量避免使用SELECT *以及加上LIMIT限制的原因之一。 查询缓存在解析一个查询语句前，如果查询缓存是打开的，那么MySQL会检查这个查询语句是否命中查询缓存中的数据。如果当前查询恰好命中查询缓存，在检查一次用户权限后直接返回缓存中的结果。这种情况下，查询不会被解析，也不会生成执行计划，更不会执行。 MySQL将缓存存放在一个引用表（不要理解成table，可以认为是类似于HashMap的数据结构），通过一个哈希值索引，这个哈希值通过查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息计算得来。所以两个查询在任何字符上的不同（例如：空格、注释），都会导致缓存不会命中。 如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、mysql库中的系统表，其查询结果都不会被缓存。比如函数NOW()或者CURRENT_DATE()会因为不同的查询时间，返回不同的查询结果，再比如包含CURRENT_USER或者CONNECION_ID()的查询语句会因为不同的用户而返回不同的结果，将这样的查询结果缓存起来没有任何的意义。 既然是缓存，就会失效，那查询缓存何时失效呢？MySQL的查询缓存系统会跟踪查询中涉及的每个表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。正因为如此，在任何的写操作时，MySQL必须将对应表的所有缓存都设置为失效。如果查询缓存非常大或者碎片很多，这个操作就可能带来很大的系统消耗，甚至导致系统僵死一会儿。而且查询缓存对系统的额外消耗也不仅仅在写操作，读操作也不例外： 任何的查询语句在开始之前都必须经过检查，即使这条SQL语句永远不会命中缓存 如果查询结果可以被缓存，那么执行完成后，会将结果存入缓存，也会带来额外的系统消耗 基于此，我们要知道并不是什么情况下查询缓存都会提高系统性能，缓存和失效都会带来额外消耗，只有当缓存带来的资源节约大于其本身消耗的资源时，才会给系统带来性能提升。但要如何评估打开缓存是否能够带来性能提升是一件非常困难的事情，也不在本文讨论的范畴内。如果系统确实存在一些性能问题，可以尝试打开查询缓存，并在数据库设计上做一些优化，比如： 用多个小表代替一个大表，注意不要过度设计 批量插入代替循环单条插入 合理控制缓存空间大小，一般来说其大小设置为几十兆比较合适 可以通过SQL_CACHE和SQL_NO_CACHE来控制某个查询语句是否需要进行缓存 最后的忠告是不要轻易打开查询缓存，特别是写密集型应用。如果你实在是忍不住，可以将query_cache_type设置为DEMAND，这时只有加入SQL_CACHE的查询才会走缓存，其他查询则不会，这样可以非常自由地控制哪些查询需要被缓存。 当然查询缓存系统本身是非常复杂的，这里讨论的也只是很小的一部分，其他更深入的话题，比如：缓存是如何使用内存的？如何控制内存的碎片化？事务对查询缓存有何影响等等，读者可以自行阅读相关资料，这里权当抛砖引玉吧。 语法解析和预处理MySQL通过关键字将SQL语句进行解析，并生成一颗对应的解析树。这个过程解析器主要通过语法规则来验证和解析。比如SQL中是否使用了错误的关键字或者关键字的顺序是否正确等等。预处理则会根据MySQL规则进一步检查解析树是否合法。比如检查要查询的数据表和数据列是否存在等等。 查询优化经过前面的步骤生成的语法树被认为是合法的了，并且由优化器将其转化成查询计划。多数情况下，一条查询可以有很多种执行方式，最后都返回相应的结果。优化器的作用就是找到这其中最好的执行计划。 MySQL使用基于成本的优化器，它尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。在MySQL可以通过查询当前会话的last_query_cost的值来得到其计算当前查询的成本。123456789mysql&gt; select * from t_message limit 10;...省略结果集mysql&gt; show status like &apos;last_query_cost&apos;;+-----------------+-------------+| Variable_name | Value |+-----------------+-------------+| Last_query_cost | 6391.799000 |+-----------------+-------------+ 示例中的结果表示优化器认为大概需要做6391个数据页的随机查找才能完成上面的查询。这个结果是根据一些列的统计信息计算得来的，这些统计信息包括：每张表或者索引的页面个数、索引的基数、索引和数据行的长度、索引的分布情况等等。 有非常多的原因会导致MySQL选择错误的执行计划，比如统计信息不准确、不会考虑不受其控制的操作成本（用户自定义函数、存储过程）、MySQL认为的最优跟我们想的不一样（我们希望执行时间尽可能短，但MySQL值选择它认为成本小的，但成本小并不意味着执行时间短）等等。 MySQL的查询优化器是一个非常复杂的部件，它使用了非常多的优化策略来生成一个最优的执行计划： 重新定义表的关联顺序（多张表关联查询时，并不一定按照SQL中指定的顺序进行，但有一些技巧可以指定关联顺序） 优化MIN()和MAX()函数（找某列的最小值，如果该列有索引，只需要查找B+Tree索引最左端，反之则可以找到最大值，具体原理见下文） 提前终止查询（比如：使用Limit时，查找到满足数量的结果集后会立即终止查询） 优化排序（在老版本MySQL会使用两次传输排序，即先读取行指针和需要排序的字段在内存中对其排序，然后再根据排序结果去读取数据行，而新版本采用的是单次传输排序，也就是一次读取所有的数据行，然后根据给定的列排序。对于I/O密集型应用，效率会高很多） 随着MySQL的不断发展，优化器使用的优化策略也在不断的进化，这里仅仅介绍几个非常常用且容易理解的优化策略，其他的优化策略，大家自行查阅吧。 查询执行引擎在完成解析和优化阶段以后，MySQL会生成对应的执行计划，查询执行引擎根据执行计划给出的指令逐步执行得出结果。整个执行过程的大部分操作均是通过调用存储引擎实现的接口来完成，这些接口被称为handler API。查询过程中的每一张表由一个handler实例表示。实际上，MySQL在查询优化阶段就为每一张表创建了一个handler实例，优化器可以根据这些实例的接口来获取表的相关信息，包括表的所有列名、索引统计信息等。存储引擎接口提供了非常丰富的功能，但其底层仅有几十个接口，这些接口像搭积木一样完成了一次查询的大部分操作。 返回结果给客户端查询执行的最后一个阶段就是将结果返回给客户端。即使查询不到数据，MySQL仍然会返回这个查询的相关信息，比如改查询影响到的行数以及执行时间等等。 如果查询缓存被打开且这个查询可以被缓存，MySQL也会将结果存放到缓存中。 结果集返回客户端是一个增量且逐步返回的过程。有可能MySQL在生成第一条结果时，就开始向客户端逐步返回结果集了。这样服务端就无须存储太多结果而消耗过多内存，也可以让客户端第一时间获得返回结果。需要注意的是，结果集中的每一行都会以一个满足①中所描述的通信协议的数据包发送，再通过TCP协议进行传输，在传输过程中，可能对MySQL的数据包进行缓存然后批量发送。 回头总结一下MySQL整个查询执行过程，总的来说分为5个步骤： 1 客户端向MySQL服务器发送一条查询请求 2 服务器首先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段 3 服务器进行SQL解析、预处理、再由优化器生成对应的执行计划 4 MySQL根据执行计划，调用存储引擎的API来执行查询 5 将结果返回给客户端，同时缓存查询结果性能优化建议 看了这么多，你可能会期待给出一些优化手段，是的，下面会从3个不同方面给出一些优化建议。但请等等，还有一句忠告要先送给你：不要听信你看到的关于优化的“绝对真理”，包括本文所讨论的内容，而应该是在实际的业务场景下通过测试来验证你关于执行计划以及响应时间的假设。 Scheme设计与数据类型优化选择数据类型只要遵循小而简单的原则就好，越小的数据类型通常会更快，占用更少的磁盘、内存，处理时需要的CPU周期也更少。越简单的数据类型在计算时需要更少的CPU周期，比如，整型就比字符操作代价低，因而会使用整型来存储ip地址，使用DATETIME来存储时间，而不是使用字符串。 这里总结几个可能容易理解错误的技巧： 通常来说把可为NULL的列改为NOT NULL不会对性能提升有多少帮助，只是如果计划在列上创建索引，就应该将该列设置为NOT NULL。 对整数类型指定宽度，比如INT(11)，没有任何卵用。INT使用16为存储空间，那么它的表示范围已经确定，所以INT(1)和INT(20)对于存储和计算是相同的。 UNSIGNED表示不允许负值，大致可以使正数的上限提高一倍。比如TINYINT存储范围是-128 ~ 127，而UNSIGNED TINYINT存储的范围却是0 - 255。 通常来讲，没有太大的必要使用DECIMAL数据类型。即使是在需要存储财务数据时，仍然可以使用BIGINT。比如需要精确到万分之一，那么可以将数据乘以一百万然后使用BIGINT存储。这样可以避免浮点数计算不准确和DECIMAL精确计算代价高的问题。 TIMESTAMP使用4个字节存储空间，DATETIME使用8个字节存储空间。因而，TIMESTAMP只能表示1970 - 2038年，比DATETIME表示的范围小得多，而且TIMESTAMP的值因时区不同而不同。 大多数情况下没有使用枚举类型的必要，其中一个缺点是枚举的字符串列表是固定的，添加和删除字符串（枚举选项）必须使用ALTER TABLE（如果只只是在列表末尾追加元素，不需要重建表）。 schema的列不要太多。原因是存储引擎的API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列，这个转换过程的代价是非常高的。如果列太多而实际使用的列又很少的话，有可能会导致CPU占用过高。 大表ALTER TABLE非常耗时，MySQL执行大部分修改表结果操作的方法是用新的结构创建一个张空表，从旧表中查出所有的数据插入新表，然后再删除旧表。尤其当内存不足而表又很大，而且还有很大索引的情况下，耗时更久。当然有一些奇淫技巧可以解决这个问题，有兴趣可自行查阅。 创建高性能索引索引是提高MySQL查询性能的一个重要途径，但过多的索引可能会导致过高的磁盘使用率以及过高的内存占用，从而影响应用程序的整体性能。应当尽量避免事后才想起添加索引，因为事后可能需要监控大量的SQL才能定位到问题所在，而且添加索引的时间肯定是远大于初始添加索引所需要的时间，可见索引的添加也是非常有技术含量的。 接下来将向你展示一系列创建高性能索引的策略，以及每条策略其背后的工作原理。但在此之前，先了解与索引相关的一些算法和数据结构，将有助于更好的理解后文的内容。 索引相关的数据结构和算法通常我们所说的索引是指B-Tree索引，它是目前关系型数据库中查找数据最为常用和有效的索引，大多数存储引擎都支持这种索引。使用B-Tree这个术语，是因为MySQL在CREATE TABLE或其它语句中使用了这个关键字，但实际上不同的存储引擎可能使用不同的数据结构，比如InnoDB就是使用的B+Tree。 B+Tree中的B是指balance，意为平衡。需要注意的是，B+树索引并不能找到一个给定键值的具体行，它找到的只是被查找数据行所在的页，接着数据库会把页读入到内存，再在内存中进行查找，最后得到要查找的数据。 在介绍B+Tree前，先了解一下二叉查找树，它是一种经典的数据结构，其左子树的值总是小于根的值，右子树的值总是大于根的值，如下图①。如果要在这课树中查找值为5的记录，其大致流程：先找到根，其值为6，大于5，所以查找左子树，找到3，而5大于3，接着找3的右子树，总共找了3次。同样的方法，如果查找值为8的记录，也需要查找3次。所以二叉查找树的平均查找次数为(3 + 3 + 3 + 2 + 2 + 1) / 6 = 2.3次，而顺序查找的话，查找值为2的记录，仅需要1次，但查找值为8的记录则需要6次，所以顺序查找的平均查找次数为：(1 + 2 + 3 + 4 + 5 + 6) / 6 = 3.3次，因为大多数情况下二叉查找树的平均查找速度比顺序查找要快。 余下原文地址：http://www.jianshu.com/p/d7665192aaaf","tags":[{"name":"mysql","slug":"mysql","permalink":"http://renpingjun.cn/tags/mysql/"},{"name":"数据库","slug":"数据库","permalink":"http://renpingjun.cn/tags/数据库/"}]},{"title":"MySQL 数据查询优化建议","date":"2017-05-01T09:08:00.000Z","path":"2017/05/01/c19537s2/","text":"引子在实际项目开发中，当MySQL表的数据量非常庞大时，一般的SQL查询效率明显下降，而且如果where语句中查询条件较多时，其查询速度根本无法容忍。假如我们查询商城的一个订单详情，查询时间高达几十秒，这么高的查询延时，任何用户都会抓狂。因此提高SQL语句查询效率，显得十分重要。 SQL语句查询效率低下原因初探 1、没有索引或者没有用到索引（这是查询慢最常见的问题，是程序设计的缺陷）； 2、I/O 吞吐量小，形成了瓶颈效应； 3、没有创建计算列导致查询不优化； 4、内存不足； 5、网络速度慢 6、查询出的数据量过大（可采用多次查询，其他的方法降低数据量） 7、锁或者死锁（这是查询慢最常见的问题，是程序设计的缺陷） 8、sp_lock,sp_who,活动的用户查看,原因是读写竞争资源； 9、返回了不必要的行和列； 10、查询语句不好，没有优化。 SQL语句查询的优化建议 1 应尽量避免在 where 子句中使用 != 或者 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。 2 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如可以在 num 上设置默认值 0 ，确保表中 num 列没有 null 值。 12select id from t where num is null; // not goodselect id from t where num = 0; // better 3 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 4 尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： 12345select id from t where num = 10 or num = 20; // not goodselect id from t where num = 10 // betterunion allselect id from t where num = 20; 5 前置百分号（%）会致使全表扫描，可以考虑全文检索。 6 慎用in 或 not in，会致使全表扫描，连续的数值可以考虑用between。 12select id from t where num in(1, 2, 3); // not goodselect id from t where num between 1 and 3; // better 7 如果在 where 子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择到运行时；它必须在编译时进行选择。然而，如果在编译时简历访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描,可以改为强制查询使用索引。 12select id from t where num = @num; // not goodselect id from t with(index(索引名)) where num = @num; // better 8 尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。 12select id from t where num/2 = 100; // not goodselect id from t where num = 100 * 2; // better 9 应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。 123456// not goodselect id from t where substring(name, 1, 3) = ’abc’–name; //以abc开头的idselect id from t where datediff(day,createdate,’2005-11-30′) = 0–’2005-11-30′; //生成的id// betterselect id from t where name like ‘abc%’select id from t where createdate &gt;= ’2005-11-30′ and createdate &lt; ’2005-12-1′; 10 不要在 where 子句中的 “=” 左边进行函数，算术运算或者其他表达式运算，否则系统将可能无法正确使用索引。 11 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。 12 毋写无意义查询，这类代码不会返回任何结果集，但是会消耗系统资源，如需要生成一个空表结构。 12select col1,col2 into #t from t where 1=0; // not goodcreate table #t(…) // better 13 很多时候用 exists 代替 in 是一个好的选择. 12select num from a where num in(select num from b); // not goodselect num from a where exists(select 1 from b where num=a.num); // better 14 并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段 sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。 15 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。 16 应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。 17 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 18 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 19 任何地方都不要使用 select from t ，用具体的字段列表代替 ，不要返回用不到的任何字段。 20 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。 21 避免频繁创建和删除临时表，以减少系统表资源的消耗。 22 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。 23 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先 create table，然后 insert。 24 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 25 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。 26 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。 27 与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。 28 在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。 29 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 30 尽量避免大事务操作，提高系统并发能力。","tags":[{"name":"mysql","slug":"mysql","permalink":"http://renpingjun.cn/tags/mysql/"},{"name":"数据库","slug":"数据库","permalink":"http://renpingjun.cn/tags/数据库/"}]},{"title":"MYSQL 基本操作指南","date":"2017-04-29T08:59:00.000Z","path":"2017/04/29/c19517s2/","text":"环境：Linux Ubuntu14.04, MYSQL5.5 1.登录数据库服务器1234567mysql -u root -p (默认端口3306)mysql -u root -p --protocol=tcp --host=localhost --port=3307 （通过tcp连接管理不同端口的MYSQL） mysql -u root -p --socket=/tmp/mysql3307.sock （通过socket套接字连接管理不同端口的MYSQL）mysql -u root -p 3306 -h 127.0.0.1 （通过端口和IP管理不同端口的MYSQL） 2.数据库操作123456789SHOW DATABASES; （显示所有数据库）CREATE DATABASE vue_ghs; （创建一个名为vue_ghs的数据库）DROP DATABASE vue_ghs; （删除数据库）USE vue_ghs; （选择将要操作的数据库）SOURCE vue_ghs.sql; （MYSQL导入.sql文件） 3.表操作12345678910111213141516171819202122SHOW TABLES; （显示所有数据表）CREATE TABLE `renpingjun` ( `id` INT( 5 ) UNSIGNED NOT NULL AUTO_INCREMENT , `username` VARCHAR( 20 ) NOT NULL , `password` CHAR( 32 ) NOT NULL , `time` DATETIME NOT NULL , `number` FLOAT( 10 ) NOT NULL , `content` TEXT NOT NULL , PRIMARY KEY ( `id` ) ) ENGINE = MYISAM ; （创建数据表renpingjun：在mysql&gt;后粘贴以下SQL语句，存储引擎为MYISAM，字段id为主键、唯一索引）DESCRIBE renpingjun; （查看renpingjun数据表结构）SELECT * FROM renpingjun; （从renpingjun数据表中检索所有记录）SELECT * FROM renpingjun WHERE username = abc AND number=1 ORDER BY id DESC; （从renpingjun数据表中检索username = abc AND number=1的记录，按字段id降序排序）INSERT INTO renpingjun (id, username, password, time, number, content) VALUES (, abc, 123456,2007-08-06 14:32:12, 23.41, hello world); （插入信息到renpingjun数据表）UPDATE renpingjun SET content = hello china WHERE username = abc; （更新数据表信息）UPDATE renpingjun SET content = REPLACE (content, aaa, bbb); （批量替换renpingjun数据表中content字段中的“aaa”为“bbb”）DELETE FROM renpingjun; （清空renpingjun数据表）DROP TABLE renpingjun; （删除renpingjun数据表）REPAIR TABLE renpingjun; （修复损坏的renpingjun数据表） 4.数据库权限操作1234567GRANT ALL PRIVILEGES ON *.* TO renpingjun@% IDENTIFIED BY 123456; （创建一个具有root权限，可从任何IP登录的用户renpingjun，密码为123456）GRANT SELECT , INSERT , UPDATE , DELETE , FILE , CREATE , DROP , INDEX , ALTER , CREATETEMPORARY TABLES , CREATE VIEW , SHOW VIEW , CREATE ROUTINE, ALTER ROUTINE, EXECUTE ON*.* TO xiawei@192.168.1.% IDENTIFIED BY 123456; （创建一个具有数据操作、结构操作权限，只能从IP为192.168.1登录的用户xiawei,密码为123456）DROP USER xiawei@%; （删除用户xiawei） 5.登出数据库服务器1exit;","tags":[{"name":"mysql","slug":"mysql","permalink":"http://renpingjun.cn/tags/mysql/"},{"name":"数据库","slug":"数据库","permalink":"http://renpingjun.cn/tags/数据库/"}]},{"title":"复制Array数组的正确姿势","date":"2017-04-01T14:35:00.000Z","path":"2017/04/01/603376a4/","text":"引子我们先假设有这样一个数组： var arr = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;] 然后再申明var arr2 = arr ，诚然此时arr2算是复制了一个和arr一样的数组，好像没什么问题。但是当我们执行arr2.pop()方法后再来看看，两个数组都变成了[‘one’, ‘two’]，这并不是我们所希望看到的结果。我们希望复制后的两个数组可以各行其是，独行于世。 for循环复制数组比较传统的做法就是使用for循环arr数组得到arr2数组，这样我们就成功复制数组arr，得道了一个新的独立的数组arr2，再次验证arr2.pop()方法，并没有对arr数组产生影响。 var arr = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]； var arr2 = []; for(var i=0;i&lt;arr.length;i++){ arr2[i]=arr[i]; } arr2.pop()； console.log(arr,arr2) // [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;],[&apos;one&apos;, &apos;two&apos;] Array.from()方法复制数组Array.from()是ES6中新增的数组方法，这个方法的作用是从一个数组或具有数组某些行为的对象中生成一个新的数组。代码示例： /*从一个数组生成新数组*/ var arr = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]； var arr2 = Array.from(arr); arr2.pop()； console.log(arr,arr2) // [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;],[&apos;one&apos;, &apos;two&apos;] ／*从具有数组某些行为的对象中生成新数组*／ var imgs = Array.from(document.querySelectorAll(&apos;img&apos;)); …扩展运算符…是ES6新增的扩展运算符，它将一个数组转化为用逗号分隔的参数序列。代码示例： var arr = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]； var arr2 = [...arr]; arr2.pop()； console.log(arr,arr2) // [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;],[&apos;one&apos;, &apos;two&apos;] 此运算符主要用于函数调用： function show(...args){ args.push(6); } show(1,2,3,4,5) //1,2,3,4,5,6","tags":[{"name":"javascript","slug":"javascript","permalink":"http://renpingjun.cn/tags/javascript/"}]},{"title":"科目一重要考點梳理（四）","date":"2017-03-26T06:52:00.000Z","path":"2017/03/26/603377a4/","text":"一 考试知识点答题技巧1.答题中所有题一个原则——安全，因此怎么做安全就怎么做。2.判断题中遇到紧急情况所有过激行为都错，比如急踩（用力踏）油门（制动），急转方向，选择题中类似的答案都错。3.能让行的都让行，能帮助的都帮助，能避让就避让，只要不抢、不急都对。4.抢救伤员一个原则先救人，救人一个原则先止血。5.无标志无灯无警路口，按照让右路——让左转——让直行的顺序判断。6.车辆变换位置都要开转向灯，唯一一个不开的就是进环岛（转盘）。7.红色是禁令、黄色是警告、蓝色是指示，三种颜色都没有是辅助。8.禁令对禁止、警告对警告、指示对指示，相同就对，不相同就错。9.黄灯亮与黄灯闪烁只一字之差。“闪烁”确保安全，“亮”不准通行，但越线的可通行。10.远光灯、近光灯的考题只能使用近光灯，不准使用远光灯。11.只有冰雪道路是下坡先行，其余都是上坡先行；如果出现两个上坡先行，就选字多的。12.有省选省，无省选县。13.户籍地对户籍地，暂住地对暂住地。 二 易错知识点答题技巧1.可以：实习驾驶员不得单独驾车上高速，须有3年驾龄的驾驶员陪同才能上高速。2.不准：牵引车辆;驾驶特种和危险品车辆;单独驾驶大客车和挂车。3.可以：鸣三次，鸣半秒钟。行车中遇到畜力车时，尽量少鸣喇叭。4.不准：郊外高音喇叭禁止，晚上23时到凌晨5时禁止。当经过不允许鸣喇叭的路段时，注意安全，禁止鸣喇叭。行进没有禁止鸣喇叭路段时，驾驶人应该尽可能少鸣喇叭。5.高架和高速：不准停车、调头、逆向行驶、上下客。 三 难题知识点解答技巧1、选择题、判断题带有这些字样的都是正确的：不能、不得、不准、不要、停车避让、减速让行、依次排队等候、系好安全带、及时、保护现场、间断轻踏、靠右行驶、按顺序。带有这些字样的都是错误的：马上、迅速、加速、不予避让、紧急制动、降低胎压、空挡滑行。2、停车停车应该停在规定停车区域内。路边临时停车不能妨碍交通。30米内不得停车：加油站、急救站、公交车站、消防栓、消防队门口。50米内不得停车：窄路、急弯、隧道、铁道路口、桥梁、陡坡、交叉路口。","tags":[{"name":"科目一","slug":"科目一","permalink":"http://renpingjun.cn/tags/科目一/"}]},{"title":"科目一重要考點梳理（三）","date":"2017-03-26T05:52:00.000Z","path":"2017/03/26/603377a3/","text":"日期類答題技巧1.事故后逃逸，不构成犯罪，并处15日以下拘留。2.小型车非营运从注册登记之日起，6年以内每2年检验1次。3.小型车非营运从注册登记之日起，超过6年不满15年的，每1年检验一次。4.初次申领驾驶证后的12个月为实习期。5.机动车驾驶证有效期分为6年、10年和长期。6.道路交通安全违法行为累积记分周期为12个月。7.驾驶人不得连续驾驶超过4小时未停车休息。8.驾驶人连续驾车超过4小时，停车休息时间不得少于20分钟。9.以不正当手段取得机动车登记或者驾驶许可的，撤销，申请人3年内不得再申请。10.被扣留的机动车30日内不接受处理，公告3个月仍不接受处理的，依法拍卖。11.机动车驾驶人发生重大事故构成犯罪的，处3年以下有期徒刑。12.机动车驾驶人逃逸，处3年以上7年以下有期徒刑。13.公安交警需要调查核实机动车来历证明的，30日内不来接受处理，不受扣留机动车时间限制。14.当事人未在事故现场报警，事后请求处理的，应当在提出请求后10日内提供证据。15.请求交警部门调解损害赔偿的，可以在收到事故认定书之日起10日内提出书面申请。16.调解参加人因故不能按期参加调解的，应提前24小时通知交警，请求变更时间。17.吊销驾驶证未满2年的不得申请驾驶证。18.撤销驾驶许可未满3年的不得申请驾驶证。19.小型申请增加大型货车准驾车型的，应当在申请前最近1个周期内没有满分记录。20.申请机动车驾驶证考试，每个科目考试1次，可以补考1次。21.应当于驾驶证有效期满90日内，向核发地申请换证。22.超过驾驶证有效期1年以上未换证的，应当注销其驾驶证。23.一个周期内记分达到12分的，应当接受为期七日的教育。24.年龄在60周岁以上，应当每1年提交一次身体检查。25.年龄在60周岁以上的，在记分周期结束后15天内，提交身体条件的证明。（各地实际执行时间情况不统一。）26.驾驶证记载的信息发生变化的，应当在30日内申请换证。27.机动车交通事故责任强制保险的保险期间为1年。28.一年内有醉酒的行为，被处罚两次以上的，吊销驾驶证，5年内不准驾驶营运机动车。29.大型、中型非营运机动车从注册登记之日起，10年内每年检验1次。30.大型、中型非营运机动车从注册登记之日起，超过10年的，每6个月检验1次。31.载客汽车从注册登记之日起，5年内每年检验1次。32.载客汽车从注册登记之日起，超过5年的，每6个月检验1次。33.申请增加大型客车准驾车型的，应当取得中型客车或者大型货车资格5年以上。34.申请增加大型客车准驾车型的，应当在申请前最近连续3个记分周期内没有满分记录。35.取得驾驶牵引车准驾车型资格2年以上，可以申请增加大型客车。36.持有大客、公交、中客驾驶证的，在1个记分周期结束后，1年内未提交体检证明的，注销驾驶证。37.载货汽车从注册登记之日起，10年以内每年检验1次。38.载货汽车从注册登记之日起，超过10年的，每6个月检验1次。39.载货汽车从注册登记之日起，超过10年的，每年检验2次。40.年龄在60周岁以上或者持有牵引车、大货驾驶证的，在1个记分周期结束后，1年内未提交体检证明，注销驾驶证。","tags":[{"name":"科目一","slug":"科目一","permalink":"http://renpingjun.cn/tags/科目一/"}]},{"title":"科目一重要考點梳理（二）","date":"2017-03-23T12:35:00.000Z","path":"2017/03/23/603377a2/","text":"一 機動車讓行 轉彎讓直行 右轉讓左轉 右方先行 二 機動車行駛速度 普通公路 無中心線：城30公40； 有中心線：城50公70； 限速30：遇雨雪沙塵暴等天氣，能見度低於50m；掉頭、轉彎、下坡；在冰雪、泥濘道路上；牽引故障車時；進出非機動車道，鐵道口，窄路齋橋等。 高速公路 兩車道：60～100，100～120 三車道：60～90，90～110，110～120","tags":[{"name":"科目一","slug":"科目一","permalink":"http://renpingjun.cn/tags/科目一/"}]},{"title":"科目一重要考點梳理（一）","date":"2017-03-23T11:35:00.000Z","path":"2017/03/23/603377a1/","text":"一 道路交通安全違法行為記12分 駕駛與准假車型不符的機動車 飲酒後駕駛機動車 造成交通事故後逃逸，尚不構成犯罪 上道路行駛的機動車未懸掛機動車牌 故意遮擋、污損、不按規定安裝機動車牌 使用偽造、變造的機動車牌、行駛證、駕駛證 使用其他機動車號牌、行駛證 駕駛機動車在高速公路上倒車、逆行、掉頭 駕駛機動車超過規定時速50% 二 道路交通安全違法行為記6分 機動車駕駛證被扣期間駕駛機動車 駕駛機動車違反道路交通信號燈通行 駕駛機動車超過規定時速20% 駕駛貨車載物超過核定載質量30%或違反規定載客 駕駛機動車在高速公路車道內停車 駕駛機動車違法佔用應車道行駛 低能見度天氣條件下，駕駛機動車在高速公路上不按規定行駛 以隱瞞、欺騙手段補領機動車駕駛證 不按規定避讓校車 駕駛機動車超過4小時未休息或休息時間小於20分鐘 三 違反交通運輸管理法規刑罰 因發生重大交通事故，致人重傷、死亡或者使公私財產遭受重大損失的，處3年以下有期徒刑或拘役 交通運輸肇事後逃逸或者尤其他特別惡劣情節的，處3～7年有期徒刑 因逃逸致人死亡的，處7年以上有期徒刑 四 機動車在高速上行駛速度及車距 能見度小於200m：開啟霧燈、近光燈、示廓燈和前後位燈；車速&lt;60km／h ；車距100m以上 能見度小於100m：開啟霧燈、近光燈、示廓燈、前後位燈和危險報警閃光燈；車速&lt;40km／h ；車距50m以上 能見度小於50m：開啟霧燈、近光燈、示廓燈、前後位燈和危險報警閃光燈；車速&lt;20km／h ；從最近出口儘快駛離高速公路","tags":[{"name":"科目一","slug":"科目一","permalink":"http://renpingjun.cn/tags/科目一/"}]},{"title":"函数绑定","date":"2017-03-13T13:35:00.000Z","path":"2017/03/13/603376a3/","text":"函数绑定需要创建一个函数，可以在特定的this环境中以指定参数调用另一个函数，常和回调函数、事件处理程序一起使用，以便在将函数作为变量传递的同时不改变函数执行环境。 我们来看下面这个例子： 1234567891011121314151617181920212223242526272829303132333435var lottery = &#123; dialog: &#123; getGoods: \"iphone 7\", getVoucher: \"100\", getNone: \"nothing\", noChance: \"no chance\" &#125;, bindEvent: function () &#123; $(\"#lottery-btn\").on('click', function () &#123; $('#lottery_canvas').addClass('runanimation'); $.ajax(&#123; type: \"get\", url: \"ajaxUrl\", dataType: \"json\", success: function (data) &#123; if (data.msg == \"success\") &#123; switch (data.status) &#123; case 0 : this.dialog.getNone; break; case 1 : this.dialog.noChance; break; case 2 : this.dialog.getVoucher; break; case 3 : this.dialog.getGoods; break; &#125; &#125; &#125;); &#125;) &#125; &#125; 在这个例子中，我创建了一个lottery对象，lottery.bindEvent()方法被分配到一个id为lottery-btn的DOM结构上。按下按钮时，调用该函数，转盘转动，发送ajax请求，根据返回的值做不同的处理。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://renpingjun.cn/tags/javascript/"}]},{"title":"How to Build Your Personal Blog in Half an Hour ?","date":"2017-03-12T13:59:00.000Z","path":"2017/03/12/603376a1/","text":"Initialize Your Work EnvironmentIn order to build your blog more quickly and successfully, you’d better install some software mentioned below. Node &amp;&amp; NPMIt is used to generate static pages. We use the Homebrew to install node, which is the missing package manager for macOS. 1$ brew install node Git1$ brew install git GithubYou need to apply for an account in github to manage your own code. Use HexoHexo is a fast, simple &amp; powerful blog framework. Install Hexo in global environment1$ npm install -g hexo create a directory and init hexo123$ mkdir blog$ cd blog$ hexo init Now you have actrually down your installation work. generate static pages.1$ hexo generate or1$ hexo g Start local service1$ hexo server Open your broswer and input localhost:4000 in address blank.","tags":[]},{"title":"Hello World","date":"2017-03-01T14:35:00.000Z","path":"2017/03/01/603376a2/","text":"title: Hello WorldWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"javascript","slug":"javascript","permalink":"http://renpingjun.cn/tags/javascript/"}]}]